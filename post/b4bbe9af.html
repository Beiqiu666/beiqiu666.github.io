<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>MySQL锁的理解 | 北秋的秘密基地</title><meta name="author" content="北秋"><meta name="copyright" content="北秋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="锁是MySQL在服务器层和存储引擎层的的并发控制。加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等，都会增加系统的开销。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL锁的理解">
<meta property="og:url" content="https://beiqiu.top/post/b4bbe9af.html">
<meta property="og:site_name" content="北秋的秘密基地">
<meta property="og:description" content="锁是MySQL在服务器层和存储引擎层的的并发控制。加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等，都会增加系统的开销。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=3622408705,4229293391&fm=253&fmt=auto&app=138&f=PNG?w=677&h=500">
<meta property="article:published_time" content="2022-06-11T05:14:00.000Z">
<meta property="article:modified_time" content="2023-12-01T19:48:02.589Z">
<meta property="article:author" content="北秋">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="MySQL锁进阶">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=3622408705,4229293391&fm=253&fmt=auto&app=138&f=PNG?w=677&h=500"><link rel="shortcut icon" href="https://z1.ax1x.com/2023/11/16/pitl5tA.jpg"><link rel="canonical" href="https://beiqiu.top/post/b4bbe9af.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"G1RGPQQRS9","apiKey":"26a0a12c0576c8b9e40f4c6bb583907a","indexName":"BeiQiuIndexName","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 北秋","link":"链接: ","source":"来源: 北秋的秘密基地","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL锁的理解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-02 03:48:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/css/icon.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/css/universe.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/css/rightMenu.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="scarecrow"><div class="scarecrow__hat"><div class="scarecrow__ribbon"></div></div><div class="scarecrow__head"><div class="scarecrow__eye"></div><div class="scarecrow__eye"></div><div class="scarecrow__mouth"></div><div class="scarecrow__pipe"></div></div><div class="scarecrow__body"><div class="scarecrow__glove scarecrow__glove--l"></div><div class="scarecrow__sleeve scarecrow__sleeve--l"></div><div class="scarecrow__bow"></div><div class="scarecrow__shirt"></div><div class="scarecrow__coat"></div><div class="scarecrow__waistcoat"></div><div class="scarecrow__sleeve scarecrow__sleeve--r"></div><div class="scarecrow__glove scarecrow__glove--r"></div><div class="scarecrow__coattails"></div><div class="scarecrow__pants"></div></div><div class="scarecrow__arms"></div><div class="scarecrow__leg"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://z1.ax1x.com/2023/11/16/pitl5tA.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-user-group"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/circle/"><i class="fa-fw fas fa-wifi"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-laptop-code"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/sponsorWall/"><i class="fa-fw fas fa-money-check-alt"></i><span> 赞助墙</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-secret"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></li><li><a class="site-page child" href="/bookmarking/"><i class="fa-fw fas fa-infinity"></i><span> 网址收藏</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2022/06/23/jCECPP.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="北秋的秘密基地"><span class="site-name">北秋的秘密基地</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-user-group"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/circle/"><i class="fa-fw fas fa-wifi"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-laptop-code"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/sponsorWall/"><i class="fa-fw fas fa-money-check-alt"></i><span> 赞助墙</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-secret"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></li><li><a class="site-page child" href="/bookmarking/"><i class="fa-fw fas fa-infinity"></i><span> 网址收藏</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL锁的理解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-11T05:14:00.000Z" title="发表于 2022-06-11 13:14:00">2022-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-01T19:48:02.589Z" title="更新于 2023-12-02 03:48:02">2023-12-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL锁的理解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>前言：<br>锁是MySQL在服务器层和存储引擎层的的并发控制。加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等，都会增加系统的开销。</p>
<hr>
<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>InnoDB实现了如下两种标准的行级锁：</p>
<ul>
<li><strong>共享锁</strong>（S Lock）：允许事务对一条行数据进行读取</li>
<li><strong>排他锁</strong>（X Lock）：允许事务对一条行数据进行删除或更新</li>
</ul>
<p>如果一个事务T1已经获得了行r的共享锁， 那么另外的事务T2可以立即获得行r的共享锁， 因为读取并没有改变行 r 的数据， 称这种情况为<strong>锁兼容</strong> (Lock Compatible)。 但若有其他的事务T3想获得行r的排他锁， 则其必须等待事务T1, T2释放行r上的共享锁——这种情况称为<strong>锁不兼容</strong>。因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<p>从上表可以发现，<strong>X锁与任何锁都不兼容，而S锁仅和S锁兼容</strong>。</p>
<p>此外， InnoDB 存储引擎支持多粒度锁定， 这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支待在不同粒度上进行加锁操作， InnoDB 存储引擎支持 一种额外的锁方式， 称之为<strong>意向锁</strong> (Intention Lock)。意向锁是将锁定的对象分为多个层次， 意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>InnoDB存储引擎支持意向锁设计比较简练，其<strong>意向锁即为表级别的锁</strong>。设计目的主要是为了在事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁</li>
<li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此<strong>意向锁不会阻塞除全表扫描以外的任何请求</strong>，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。</p>
<p>如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。</p>
<p>故表级意向锁和行级锁的兼容性如下表所示：</p>
<h1 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h1><p>InnoDB有三种行锁的算法：</p>
<ul>
<li><p><strong>Record Lock</strong></p>
<p>简单说就是单个行记录上加锁，防止事务间修改或删除数据。Record Lock总是会去锁住索引记录，如果表建立的时候没有设置任何一个索引，InnoDB存储引擎会使用隐式的主键来进行锁定。</p>
</li>
<li><p><strong>Gap Lock</strong></p>
<p>间隙锁，表示只锁住一段范围，<strong>不锁记录本身</strong>，通常表示两个索引记录之间，或者索引上的第一条记录之前，或者最后一条记录之后的锁。</p>
</li>
<li><p><strong>Next-Key Lock</strong></p>
<p>Gap Lock + Record Lock，锁定一个范围及锁定记录本身。例如一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-key Locking的区间为<code>(负无穷, 10), (10, 11), (11, 13), (12, 20), (20, 正无穷)</code>。需要理解一点，InnoDB中加锁都是给所有记录一条一条加锁，并没有一个直接的范围可以直接锁住，所以会生成多个区间。</p>
</li>
</ul>
<p>MySQL默认情况下使用RR的隔离级别，而<strong>Next-key Lock正是为了解决RR隔离级别下的不可重复读问题和幻读问题</strong>。所谓不可重复读就是一个事务内执行相同的查询，会看到不同的行记录，在RR隔离级别下这是不允许的。</p>
<p>假设索引上有记录<code>1，4，5，8，12</code>，我们执行类似语句<code>SELECT … WHERE col &gt; 10 FOR UPDATE</code>。如果我们不在<code>(8, 12)</code>之间加上Next-key Lock，另外一个会话就可能向其中插入一条记录9，再执行一次相同的<code>SELECT ... FOR UPDATE</code>，就会看到新插入的记录。这也是为什么MySQL插入一条记录时，需要判断下一条记录上是否加锁了，如果加锁就需要等待。</p>
<p><strong>InnoDB对行的查询默认采用Next-key算法</strong>。然而，<strong>当查询条件为等值时，且索引有唯一属性时（就是只锁定一条记录），InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock</strong>，即仅锁住索引本身，而不是一个范围，因为此时不会产生重复读问题。</p>
<h1 id="锁读取"><a href="#锁读取" class="headerlink" title="锁读取"></a>锁读取</h1><blockquote>
<p><strong>一致性非锁定读</strong>(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVCC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJdOK"><img src="https://s1.ax1x.com/2022/07/04/jJJdOK.jpg" alt="jJJdOK.jpg"></a></p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为<strong>行多版本技术</strong>。由此带来的并发控制，称之为<strong>多版本并发控制</strong>(Multi Version Concurrency Control, MVCC)。**InnoDB是通过undo log来实现MVCC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p><strong>一致性非锁定读是InnoDB默认的读取方式</strong>，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。</p>
<p>我们下面举个例子来详细说明一下上述的情况。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJ0eO"><img src="https://s1.ax1x.com/2022/07/04/jJJ0eO.jpg" alt="jJJ0eO.jpg"></a></p>
<p>首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有提交。与此同时，在开启另一个会话B，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。</p>
<p>由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p>当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了：</p>
<ul>
<li><strong>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本</strong>，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。</li>
<li><strong>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据</strong>，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</li>
</ul>
<p>在默认情况下，即事务的隔离级别是repeatable read模式下，InnoDB存储引擎的SELECT操作使用的是一致性非锁定读。但是在某些情况下，用户需要显示的读取数据操作进行加锁保证数据逻辑的一致性。</p>
<p>InnoDB提供了两种方式实现一致性锁定读：</p>
<ul>
<li><code>select … for udpate</code>，对读取的行加了X锁</li>
<li><code>select … lock in share mode</code>，对读取的行加了S锁</li>
</ul>
<p>需要注意的是，以上两种语句必须在一个事务当中，当事务提交了，锁也就释放了。</p>
<h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><blockquote>
<p>因为不同锁之间的兼容性关系，有时候一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是<strong>阻塞</strong>。</p>
</blockquote>
<p>在InnoDB，参数<code>innodb_lock_wait_timeout</code>用来控制等待的时间，<code>innodb_rollback_on_timeout</code>用来设定是否在等待超时后回滚。前者是动态的，后者是静态的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_lock_wait_timeout&#x27;\G;</span><br><span class="line">*************************** 1. row</span><br><span class="line">Variable_name: innodb_lock_wait_timeout</span><br><span class="line">Value: 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;innodb_rollback_on_timeout&#x27;\G;</span><br><span class="line">1. row</span><br><span class="line">: innodb_rollback_on_timeout</span><br><span class="line">Value: OFF</span><br></pre></td></tr></table></figure>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种相互等待的现象。若无外力作用，事务都将无法推进下去。</p>
<p>解决死锁做简单的方法就是超时，即当两个事务互相等待时，当一个等待时间超过了某一阈值，其中一个事务进行回滚，另一个等待的事务就能继续进行。</p>
<p>但是如果超时的事务所占权重比较大，如事务更新了很多行，占用了较多的undo log，回滚这个事务的时间相对于另一个事务所占用的时间可能会更多，就显得不合适了。</p>
<p>因此，除了超时机制，当前数据库都普遍采用<strong>等待图</strong>（wait-for graph）的方式来进行死锁检测。</p>
<p>wait-for graph要求数据库保存以下两种信息:</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在 wait-for graph中,事务为图中的节点。而在图中,事务T1指向T2边的定义为:</p>
<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源,也就是事务之间在等待相同的资源,而事务T1发生在事务T2的后面</li>
</ul>
<p>来看一个例子：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJay6"><img src="https://s1.ax1x.com/2022/07/04/jJJay6.jpg" alt="jJJay6.jpg"></a></p>
<p>在 Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4,故在wait-for graph中应有4个节点。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJUQx"><img src="https://s1.ax1x.com/2022/07/04/jJJUQx.jpg" alt="jJJUQx.jpg"></a></p>
<p>通过上图可以发现存在回路(t1,t2)，因此存在死锁。可以发现wait-for graph是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。</p>
<h1 id="InnoDB锁相关状态查询"><a href="#InnoDB锁相关状态查询" class="headerlink" title="InnoDB锁相关状态查询"></a>InnoDB锁相关状态查询</h1><p>用户可以使用<code>INFOMATION_SCHEMA</code>库下的<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来监控当前事务并分析可能出现的锁问题。的关键字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;</span><br><span class="line">************************************* 1.row *********************************************</span><br><span class="line">trx_id: 7311F4</span><br><span class="line">trx_state: LOCK WAIT</span><br><span class="line">trx_started: 2010-01-04 10:49:33</span><br><span class="line">trx_requested_lock_id: 7311F4:96:3:2</span><br><span class="line">trx_wait_started: 2010-01-04 10:49:33</span><br><span class="line">trx_weight: 2</span><br><span class="line">trx_mysql_thread_id: 471719</span><br><span class="line">trx_query: select * from parent lock in share mode</span><br></pre></td></tr></table></figure>
<p>表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表，该表的关键字段组成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM.INNODB_LOCKS\G;</span><br><span class="line">1. row</span><br><span class="line">lock_id: 16219:56:4:5</span><br><span class="line">lock_trx_id: 16219</span><br><span class="line">lock_mode: X,GAP</span><br><span class="line">lock_type: RECORD</span><br><span class="line">lock_table: `test`.`z`</span><br><span class="line">lock_index: b</span><br><span class="line">lock_space: 56</span><br><span class="line">lock_page: 4</span><br><span class="line">lock_rec: 5</span><br><span class="line">lock_data: 6, 7</span><br><span class="line">2. row</span><br><span class="line">lock_id: 16218:56:4:5</span><br><span class="line">: 16218</span><br><span class="line">lock_mode: X,GAP</span><br><span class="line">lock_type: RECORD</span><br><span class="line">lock_table: `test`.`z`</span><br><span class="line">lock_index: b</span><br><span class="line">lock_space: 56</span><br><span class="line">lock_page: 4</span><br><span class="line">lock_rec: 5</span><br><span class="line">lock_data: 6, 7</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM.INNODB_LOCK_WAITS\G;</span><br><span class="line">*******************************************1.row************************************</span><br><span class="line">requesting_trx_id: 7311F4</span><br><span class="line">requesting_lock_id: 7311F4:96:3:2</span><br><span class="line">blocking_trx_id: 730FEE</span><br><span class="line">blocking_lock_id: 730FEE:96:3:2</span><br></pre></td></tr></table></figure>
<p>通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。</p>
<h1 id="锁的应用实例解析"><a href="#锁的应用实例解析" class="headerlink" title="锁的应用实例解析"></a>锁的应用实例解析</h1><p>有一点需要特别注意，MySQL怎么使用锁，与事务的隔离级别、列上的索引状况等密切相关。单拎出一条SQL语句来讨论加锁的方式以及范围而不考虑使用场景，都是耍流氓的行为。</p>
<p>下面就不同场景下锁的使用情况做一下对比，深入理解上面的理论知识。</p>
<h2 id="场景1：RR隔离级别-主键索引"><a href="#场景1：RR隔离级别-主键索引" class="headerlink" title="场景1：RR隔离级别+主键索引"></a>场景1：RR隔离级别+主键索引</h2><p>首先根据如下代码创建测试表t，然后开启两个事务进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t(a int primary key);</span><br><span class="line">insert into t select 1;</span><br><span class="line">insert into t select 2;</span><br><span class="line">insert into t select 5;</span><br><span class="line">insert into t select 7;</span><br><span class="line">insert into t select 9;</span><br></pre></td></tr></table></figure>
<p>开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where a=5 for update;</span><br></pre></td></tr></table></figure>
<p>开启事务2并提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t select 4;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>表t共有1、2、5、7、9五个值，在上面的例子中，在事务1中首先对<code>a=5</code>进行X锁定，而由于a是主键且唯一，因此锁定的仅是5这个值，而不是（2,5）这个范围。这样在事务2中插入值4而不会阻塞，可以立即插入并返回。即锁定由Next-key Lock算法降级为Record Lock，从而提高应用的并发性。</p>
<p>需要意的一点是，对于唯一键值的锁定，<strong>Next-Key Lock降级为Record Lock仅存在于查询所有的唯一索引列</strong>。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是range类型查询，而不是const类型查询，故InnoDB存储引擎依然使用Next-Key Lock进行锁定。</p>
<p>但如果对主键进来范围查询时，锁的范围是怎么样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where a&lt;=5 for update;</span><br></pre></td></tr></table></figure>
<p>针对下面的sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into test.t select 6;</span><br><span class="line">insert into test.t select 8</span><br></pre></td></tr></table></figure>
<p>第一条会产生锁等待，而第二条可以插入成功。</p>
<p>表t共有1、2、5、7、9五个值，在上面的例子中，在事务1中执行<code>a&lt;=5</code>范围查询时，事务1加锁范围是<code>(负无穷, 1)、(1, 2)、(2, 5)、(5, 7)</code>，且<code>1、2、5、7</code>这四条记录也都加锁了，也就是说再插入<code>&lt;=7</code>的记录都是会产生锁等待，插入记录8是成功的。</p>
<p>那么InnoDB如何判断是否允许插入数据呢？对于普通索引，insert的加锁策略是：查找小于等于 insert_rec 的第一条记录，然后查看第一条记录的下一个记录是否有Gap锁，有则等待，没有则插入。比如说我们插入6这条记录，首先定位<code>&lt;=6</code>的记录，也就是5，然后确认5的下一条记录是否锁住了Gap，这里也就是7，当7这条记录有锁是代表锁住的是<code>(5, 7)</code>这个范围，就不允许插入（会申请一把插入意向锁），保证了可重复读。证明了在RR隔离级别下使用了Next-key Lock来保证其“可重复读”的特性。如果没有锁就直接插入即可。</p>
<p>但是如果插入的记录有唯一约束时，只判断下一条记录是否锁住了Gap就不行了，显然会插入重复数据破坏唯一性。这时还会把插入的记录与前一条数据进行比较，如果相同则给插入记录的前一条记录加S Lock（lock in share mode），加锁成功则返回duplicate key，否则等待S Lock。</p>
<p>这个地方可能有人会有一个疑问，为什么MySQL在加锁时，不直接加5这条记录本身以及&lt;5的记录呢？为什么还要给加锁呢？因为(5, 7)加不加锁并不会影响RR级别可重复读的特性。其实这就跟B+树有关系了，首先MySQL定位到1这条记录并加锁，然后顺着1往后读取数据并加锁，直到读取到第一条不匹配数据才能确定是否停止继续读取数据，而在RR隔离级别下只要被读到的数据都需要进行加锁。如果查询条件是&lt;5，那么加锁只会加到5这条记录为止。</p>
<p>如果是在RC隔离级别下，只会对符合条件的记录进行加记录锁，不会对满足条件的下一条记录进行加锁。</p>
<h2 id="场景2：RR隔离级别-普通索引"><a href="#场景2：RR隔离级别-普通索引" class="headerlink" title="场景2：RR隔离级别+普通索引"></a>场景2：RR隔离级别+普通索引</h2><p>正如上面所介绍的，Next-Key Lock降级为Record Lock仅在查询的列是唯一索引且条件为等值查询的情况下。若是辅助索引，则情况会完全不同，</p>
<p>首先根据如下代码创建测试表z：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table z(id int primary key,b int,index(b));</span><br><span class="line">insert into z values(1,1);</span><br><span class="line">insert into z values(3,1);</span><br><span class="line">insert into z values(5,3);</span><br><span class="line">insert into z values(7,6);</span><br><span class="line">insert into z values(10,8);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where b=3 for update;</span><br></pre></td></tr></table></figure>
<p>这时SQL语句通过索引列b进行查询，因此其使用传统的Next-key Locking技术加锁，并且由于有两个索引，其需要分别进行锁定。对于聚集索引，其仅对列id等于5的索引加上Record Lock。那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 z 表进行更新，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。</p>
<p>而对于辅助索引，其加上的是Next-key Lock，锁定的范围是（1, 3），特别需要注意的是，InnoDB存储引擎还会对辅助索引下一个键值加上Gap lock，即还有一个辅助索引范围为（3, 6）的锁。</p>
<p>此时，若在新的事务2中运行下面的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from z where id=5 lock in share mode;</span><br><span class="line">insert into z select 2,1;</span><br><span class="line">insert into z select 4,2;</span><br><span class="line">insert into z select 6,6;</span><br></pre></td></tr></table></figure>
<p>第一个SQL语句，在事务1中执行的SQL语句已经对聚集索引中的列“a=5”的值加上X锁，因此执行会被阻塞。</p>
<p>第二SQL语句，主键插入2，没有问题，插入的辅助索引值1也不在锁定的范围（1,3）中，因此可以执行成功。</p>
<p>第三个SQL语句，主键插入4，没有问题，插入的辅助索引值2在锁定的范围（1,3）中，因此执行会被阻塞。</p>
<p>第四个SQL语句，插入的主键6没有被锁定，6也不在范围（1,3）之间。但插入的值6在另一个锁定的范围（3,6）中，故同样需要等待。</p>
<p>在RR隔离级别下，对于INSERT的操作，其会检查插入记录的下一条记录是否被锁定，若已经被锁定，则不允许操作，从而避免不可重复读问题。而下面的SQL语句，不会被阻塞，可以立即执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into z select 8,6;</span><br><span class="line">insert into z select 2,0;</span><br><span class="line">insert into z select 6,7;</span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看到，Gap Lock的作用是为了阻止多个事务将记录插入到同一个范围内，解决“不可重复读”问题的产生。例如在上面的例子中，事务1中用户已经锁定了b=3的记录，若此时没有Gap Lock锁定<code>(3, 6)</code>，那么用户可以插入索引b列为3的记录，这会导致事务1中的用户再次执行同样的查询时会返回不同的记录，即产生不可重复读问题。</p>
<p>这里有一个问题值得思考一下，为什么插入<code>(6, 6)</code>不允许，而插入<code>(8, 6)</code>是允许的。这跟InnoDB索引结构有关系，我们知道二级索引是指向主键，所以结构如：<code>(1, 1), (1, 3), (3, 5), (6, 7), (8, 10)</code>。真正的Gap锁锁住的也是<code>((1, 1), (1, 3))</code>这样的结构，所以当我们插入<code>(6, 6)</code>时，需要插入到<code>(3, 5), (6, 7)</code>之间，这区间被锁，所以无法插入；而我们插入<code>(8, 6)</code>是需要插入到<code>(6, 7), (8, 10)</code>之间，没有锁存在，所以可以插入成功。</p>
<p>另外，在RR隔离级别下，我们访问条件为二级索引的情况下，就算访问一条不存在的记录同样需要加Next-key Lokcs，比如我们查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from z where b=7 for update;</span><br></pre></td></tr></table></figure>
<p>InnoDB会对(6, 8)这个区间加了Gap Lock，也就是说插入这个区间的数据都会被阻塞。</p>
<p>虽然在RR隔离级别默认使用Gap Lock，但用户可以通过以下两种方式来显式地关闭Gap Lock：</p>
<ul>
<li>将事务的隔离级别设置为READ COMMITTED；</li>
<li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1；</li>
</ul>
<p>当设置了上述参数或隔离级别调整到<strong>READ COMMITTED</strong>时，除了外键约束和唯一性检查（duplicate key）依然需要Gap Lock，其余情况仅使用Record Lock进行锁定。但需要知道的是，上述设置破坏了事务的隔离性，并且对于MySQL复制来说，可能会导致主从数据的不一致。虽然MySQL目前默认隔离级别是RR，但是基本生产环境标配基本都是RC隔离级别+ROW格式。</p>
<h2 id="场景3：RC隔离级别-主键索引"><a href="#场景3：RC隔离级别-主键索引" class="headerlink" title="场景3：RC隔离级别+主键索引"></a>场景3：RC隔离级别+主键索引</h2><p>将事务隔离级别切为RC，开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where id&gt;3 for update;</span><br></pre></td></tr></table></figure>
<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into z select 6,6;</span><br></pre></td></tr></table></figure>
<p>可以执行成功。证明在事务1执行主键范围for update时，事务2对这个范围扔可以申请写锁。证明RC隔离级别没有使用NEXT-KEY Lock，而是使用行级锁锁住对应的记录。</p>
<h2 id="场景4：RC隔离级别-普通索引"><a href="#场景4：RC隔离级别-普通索引" class="headerlink" title="场景4：RC隔离级别+普通索引"></a>场景4：RC隔离级别+普通索引</h2><p>将事务隔离级别切为RC，开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where b&gt;3 for update;</span><br></pre></td></tr></table></figure>
<p>此时，若在新的事务2中运行下面的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into z select 8,4;</span><br><span class="line">update z set b = 10 where b = 6;</span><br><span class="line">update z set b = 10 where b = 1;</span><br></pre></td></tr></table></figure>
<p>第一个SQL语句，插入数据到事务1的for update范围内是可以的，因为这里事务1在RC模式下没有加NEXT-KEY LOCK锁，所以可以插入数据。</p>
<p>第二个SQL语句，会出现锁等待，我们选择普通索引作为条件，此时MySQL给普通索引b&gt;3的记录都会加行锁。同时，这些记录对应主键索引上的记录也都加上了锁</p>
<p>第三个SQL语句，插入成功，说明b&lt;3的记录都无锁。</p>
<h2 id="场景5：RR-无索引"><a href="#场景5：RR-无索引" class="headerlink" title="场景5：RR + 无索引"></a>场景5：RR + 无索引</h2><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的</strong>，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将会给所有记录加锁</strong>。</p>
<p>在RR隔离级别下，由于查询条件没有索引，那么InnoDB需要扫描所有数据来查找数据，对于扫描过的数据InnoDB都会加上锁，并且是加Next-key lock。</p>
<p>建立测试表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tab_no_index(id int,b int) engine=innodb;</span><br><span class="line">insert into tab_no_index values(1,1),(2,2),(3,3),(4,4),(100,100);</span><br></pre></td></tr></table></figure>
<p>开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tab_no_index where id = 1 for update;</span><br></pre></td></tr></table></figure>
<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tab_no_index values(5,5);</span><br></pre></td></tr></table></figure>
<p>这时候，并不能插入成功。看起来事务1只给一行加了排他锁，但事务2在请求其他行的排他锁时，却出现了锁等待。原因就在于没有索引的情况下，InnoDB只能扫描所有记录（锁住所有记录）。当我们给其增加一个唯一索引后，InnoDB就只锁定了符合条件的行。</p>
<p>当我们给其增加一个唯一索引后，InnoDB就只锁定了符合条件的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tab_with_index(id int,b int,primary key(id));</span><br><span class="line">insert into tab_with_index values(1,1),(2,2),(3,3),(4,4),(100,100);</span><br></pre></td></tr></table></figure>
<p>开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tab_with_index where id = 1 for update;</span><br></pre></td></tr></table></figure>
<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tab_with_index where id = 2 for update;</span><br></pre></td></tr></table></figure>
<p>由这个例子可以看出，对于id是主键索引的情况下，只锁了id=1这一行记录。其余的行都是可以进行DML操作的，但前提条件是以id为条件。如果是以b字段为条件，那么还是会锁的。</p>
<h2 id="场景6：RC-无索引"><a href="#场景6：RC-无索引" class="headerlink" title="场景6：RC + 无索引"></a>场景6：RC + 无索引</h2><p>上面演示了在RR隔离级别下，对于where条件无索引的情况下，InnoDB是对所有记录加Next-key Locks。</p>
<p>但是在RC隔离级别下，对于where条件无索引的情况下，则不会对所有记录加锁，而是只对命中的数据的聚簇索引加X锁。</p>
<p>同样针对tab_no_index``表，开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">delete from tab_no_index where id = 1;</span><br></pre></td></tr></table></figure>
<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from tab_no_index where id = 99;</span><br><span class="line">update tab_no_index set id=2 where id=100;</span><br><span class="line">insert into tab_no_index select 99,99;</span><br></pre></td></tr></table></figure>
<p>都可以执行成功。</p>
<h2 id="沙场练兵"><a href="#沙场练兵" class="headerlink" title="沙场练兵"></a>沙场练兵</h2><p>有了上面的分场景演习，下面就两条简单SQL进行一场加锁分析的实战。</p>
<p>下面两条简单的SQL，加什么锁？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where id = 10;</span><br><span class="line">delete from t1 where id = 10;</span><br></pre></td></tr></table></figure>
<p>一眼看去，不经大脑的回答是：</p>
<ul>
<li>SQL1：不加锁。因为MySQL是使用多版本并发控制的，读不加锁</li>
<li>SQL2：对id = 10的记录加写锁 (走主键索引)</li>
</ul>
<p>可能是正确的，也有可能是错误的，已知条件不足，要回答这个问题，还缺少几个前提条件：</p>
<ul>
<li>id列是不是主键？</li>
<li>当前系统的隔离级别是什么？</li>
<li>id列如果不是主键，那么id列上有索引吗？</li>
<li>id列上如果有二级索引，那么这个索引是唯一索引吗？</li>
</ul>
<p><strong>组合一：id列是主键，RC隔离级别</strong></p>
<p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：<code>delete from t1 where id = 10;</code> 只需要将主键上，id = 10的记录加上X锁即可。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJTYj"><img src="https://s1.ax1x.com/2022/07/04/jJJTYj.jpg" alt="jJJTYj.jpg"></a></p>
<p><strong>组合二：id唯一索引+RC</strong></p>
<p>id是unique索引，而主键是name列。由于id是unique索引，因此delete语句会选择id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。</p>
<p>为什么聚簇索引上的记录也要加锁？如果并发的一个SQL，是通过主键索引来更新：<code>update t1 set id = 100 where name = ‘d’;</code> 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p>
<p>若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJL60"><img src="https://s1.ax1x.com/2022/07/04/jJJL60.jpg" alt="jJJL60.jpg"></a></p>
<p><strong>组合三：id非唯一索引+RC</strong></p>
<p>相对于组合一、二，id列不再唯一，只有一个普通的索引。</p>
<p>满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJbpn"><img src="https://s1.ax1x.com/2022/07/04/jJJbpn.jpg" alt="jJJbpn.jpg"></a></p>
<p><strong>组合四：id无索引+RC</strong></p>
<p>这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？换句话说，全表扫描时，会加什么锁？</p>
<p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJqlq"><img src="https://s1.ax1x.com/2022/07/04/jJJqlq.jpg" alt="jJJqlq.jpg"></a></p>
<p>为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录都锁上了。</p>
<p>在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p>
<p><strong>组合五：id主键+RR</strong></p>
<p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。</p>
<p>id列是主键列，Repeatable Read隔离级别，针对<code>delete from t1 where id = 10;</code> 这条SQL，加锁与组合一：[id主键，Read Committed]一致。</p>
<p><strong>组合六：id唯一索引+RR</strong></p>
<p>与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p>
<p><strong>组合七：id非唯一索引+RR</strong></p>
<p>RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。那么RR隔离级别下，如何防止幻读呢？</p>
<p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行<code>delete from t1 where id = 10;</code> 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJ7fs"><img src="https://s1.ax1x.com/2022/07/04/jJJ7fs.jpg" alt="jJJ7fs.jpg"></a></p>
<p>相对于组合三：[id列上非唯一锁，Read Committed]看似相同，其实却有很大的区别。</p>
<p>最大的区别在于，多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，是加载两条记录之间的位置，GAP锁有何用？</p>
<p><strong>这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键</strong>。</p>
<p>GAP锁锁住的位置，不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读(例如：<code>select * from t1 where id = 10 for update;</code>)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p>
<p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p>
<p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间、[10,b]与[10,d]间、[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。</p>
<p>因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p>
<p>Insert操作，如insert [10,a]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p>
<p>既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？ GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。</p>
<p>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：<code>delete from t1 where id = 10;</code>首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p>
<p><strong>组合八：id无索引+RR</strong></p>
<p>id列上没有索引。此时SQL：<code>delete from t1 where id = 10;</code>没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jJJOXV"><img src="https://s1.ax1x.com/2022/07/04/jJJOXV.jpg" alt="jJJOXV.jpg"></a></p>
<p>这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p>
<p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p>
<p>当然，跟组合四：[id无索引, Read Committed]类似，这个情况下，MySQL也做了一些优化，就是所谓的<code>semi-consistent read</code>。<code>semi-consistent read</code>开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。</p>
<p>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发<code>semi-consistent read</code>，来缓解加锁开销与并发影响，但是<code>semi-consistent read</code>本身可能会带来其他问题。</p>
<p><strong>组合九：Serializable</strong></p>
<p>Serializable隔离级别。对于SQL2：<code>delete from t1 where id = 10;</code> 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致</p>
<p>Serializable隔离级别，影响的是SQL1：<code>select * from t1 where id = 10;</code>这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p>
<p>MVCC 最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC</p>
<p>在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p>
<hr>
<p>本文为百度文章高级互联网专家的原创文章，本篇仅供学习使用，尊重原创</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1709427910908845097&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709427910908845097&amp;wfr=spider&amp;for=pc</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/MySQL%E9%94%81%E8%BF%9B%E9%98%B6/">MySQL锁进阶</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=3622408705,4229293391&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=677&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/f29ac09e.html" title="Java链式调用"><img class="cover" src="https://z1.ax1x.com/2023/12/01/pisNkFJ.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java链式调用</div></div></a></div><div class="next-post pull-right"><a href="/post/1690b38e.html" title="服务网格总结"><img class="cover" src="https://s1.ax1x.com/2022/07/05/jYhAaD.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">服务网格总结</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://z1.ax1x.com/2023/11/16/pitl5tA.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="avatar"/></div><div class="author-info__name">北秋</div><div class="author-info__description">慢慢来，会很快</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=3257567251&amp;website=www.qtxml.cn" target="_blank" title="QQ"><i class="iconfont icon-QQ"></i></a><a class="social-icon" href="https://beiqiu.top/img/wx.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://space.bilibili.com/487131549?spm_id_from=333.1007.0.0" target="_blank" title="哔哩哔哩"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://github.com/Beiqiu666" target="_blank" title="Github"><i class="iconfont icon-githublogo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">坚持很难但也很酷，不管做什么都不要轻易放弃。你无法让时间停止，但你可以决定接下来的每一分钟该怎么度过。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">锁的类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">锁的算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E8%AF%BB%E5%8F%96"><span class="toc-number">3.</span> <span class="toc-text">锁读取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">4.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB%E9%94%81%E7%9B%B8%E5%85%B3%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.</span> <span class="toc-text">InnoDB锁相关状态查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">锁的应用实例解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9ARR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.</span> <span class="toc-text">场景1：RR隔离级别+主键索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9ARR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.</span> <span class="toc-text">场景2：RR隔离级别+普通索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF3%EF%BC%9ARC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">7.3.</span> <span class="toc-text">场景3：RC隔离级别+主键索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF4%EF%BC%9ARC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">7.4.</span> <span class="toc-text">场景4：RC隔离级别+普通索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF5%EF%BC%9ARR-%E6%97%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.</span> <span class="toc-text">场景5：RR + 无索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF6%EF%BC%9ARC-%E6%97%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">7.6.</span> <span class="toc-text">场景6：RC + 无索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E5%9C%BA%E7%BB%83%E5%85%B5"><span class="toc-number">7.7.</span> <span class="toc-text">沙场练兵</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/xy272701.html" title="闲鱼干货资料"><img src="https://img.39zn.cn/data/upload/ueditor/20200703/5efebbe573b25.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="闲鱼干货资料"/></a><div class="content"><a class="title" href="/post/xy272701.html" title="闲鱼干货资料">闲鱼干货资料</a><time datetime="2023-07-27T03:50:33.000Z" title="发表于 2023-07-27 11:50:33">2023-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c8f15973.html" title="北秋有话说"><img src="https://z1.ax1x.com/2023/12/01/pisNPwF.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="北秋有话说"/></a><div class="content"><a class="title" href="/post/c8f15973.html" title="北秋有话说">北秋有话说</a><time datetime="2023-05-14T05:14:00.000Z" title="发表于 2023-05-14 13:14:00">2023-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e8c9c076.html" title="React通过useEffect使用定时器"><img src="https://p7.itc.cn/images01/20211123/ca47074f55954f32a596141cc77aeb17.jpeg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="React通过useEffect使用定时器"/></a><div class="content"><a class="title" href="/post/e8c9c076.html" title="React通过useEffect使用定时器">React通过useEffect使用定时器</a><time datetime="2022-08-09T05:14:00.000Z" title="发表于 2022-08-09 13:14:00">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9ea696d1.html" title="远程过程调用(RPC)详解"><img src="https://s1.ax1x.com/2022/07/10/jyJOQx.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="远程过程调用(RPC)详解"/></a><div class="content"><a class="title" href="/post/9ea696d1.html" title="远程过程调用(RPC)详解">远程过程调用(RPC)详解</a><time datetime="2022-07-09T05:14:00.000Z" title="发表于 2022-07-09 13:14:00">2022-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/788b6b51.html" title="MyBatis缓存"><img src="https://s1.ax1x.com/2022/06/27/jVSBAs.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/img/404.gif'" alt="MyBatis缓存"/></a><div class="content"><a class="title" href="/post/788b6b51.html" title="MyBatis缓存">MyBatis缓存</a><time datetime="2022-06-26T02:20:21.000Z" title="发表于 2022-06-26 10:20:21">2022-06-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s1.ax1x.com/2022/06/23/jCECPP.jpg')"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">公益广告</p><div class="bg-ad"><div>国家反诈中心APP，您的诈骗克星！举报犯罪，风险警示，防护知识应有尽有，守护好您的财产安全！</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://www.hack-gov.com.cn/posts/21480.html">下载（国家反诈中心） APP</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">修仙导航</p><ul class="ft-links"><li><a href="https://beiqiu.top/photos/">来点壁纸</a><a href="https://beiqiu.top/music/">北秋音乐</a></li><li><a href="https://beiqiu.top/sponsorWall/">来杯咖啡</a><a href="https://beiqiu.top/comments/">留点什么</a></li><li><a href="https://beiqiu.top/about/">关于博主</a><a href="https://beiqiu.top/archives/">文章归档</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链</p><div class="ft-img-group"><div class="img-group-item"><a href="https://beiqiu.top"><img src="https://z1.ax1x.com/2023/11/16/pitl5tA.jpg" alt=""/></a></div><div class="img-group-item"><a href="https://beiqiu.top"><img src="https://z1.ax1x.com/2023/11/16/pitl5tA.jpg" alt=""/></a></div><div class="img-group-item"><a href="https://beiqiu.top"><img src="https://z1.ax1x.com/2023/11/16/pitl5tA.jpg" alt=""/></a></div><div class="img-group-item"><a href="https://beiqiu.top"><img src="https://z1.ax1x.com/2023/11/16/pitl5tA.jpg" alt=""/></a></div></div></div></div><div class="copyright">&copy;2021 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 北秋</div><div class="footer_custom_text"><a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-%23f37f40?logo=github" title="世界最大的开源仓库"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a>&nbsp;<a target="_blank" href="https://space.bilibili.com/487131549?spm_id_from=333.1007.0.0"><img src="https://img.shields.io/badge/Exchange-Bilibili-%23ec8bb0?logo=bilibili" title="直达北秋Up主页"></a>&nbsp;<a target="_blank" href="https://beiqiu.top/img/wx.jpg"><img src="https://img.shields.io/badge/%E5%8C%97%E7%A7%8B-%E7%82%B9%E5%87%BB%E8%81%94%E7%B3%BB%E6%88%91%E5%97%B7-%2307c160?logo=wechat" title="链接北秋"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.beiqiu.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.beiqiu.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div id="message-container"></div><div class="aplayer no-destroy" data-id="7497337557" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script defer src="https://npm.elemecdn.com/jquery@0.0.3/dist/jquery.min.js"></script><script data-pjax defer src="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/js/chocolate.js"></script><canvas id="universe"></canvas><script data-pjax defer src="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/js/universe.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/beiqiu666/bq-blog@0.0.3/overall-situation/js/rightMenu.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuNormal"><a class="rightMenu-item menu-link" id="menu-radompage" href="javascript:bq.toRandomPost()"><i class="fa-solid fa-shoe-prints"></i><span>随便逛逛</span></a><div class="rightMenu-item" id="menu-translate"><i class="fa-solid fa-earth-asia"></i><span>繁简切换</span></div><div class="rightMenu-item" id="menu-darkmode"><i class="fa-solid fa-moon"></i><span>切换模式</span></div><div class="rightMenu-item" id="menu-print"><i class="fa-solid fa-print fa-fw"></i><span>打印页面</span></div></div></div><div id="rightmenu-mask"></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>