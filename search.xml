<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>这是一个Java程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js接受后端流数据</title>
      <link href="/post/92b7df7c.html"/>
      <url>/post/92b7df7c.html</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>本篇博客来源于各大平台知识之间的总结，如有错误，还望各大网友帮忙指正！</p><hr><h2 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">download</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> fileInfo = &#123;</span><br><span class="line">        要传的数据</span><br><span class="line">    &#125;;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;接口&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(fileInfo),</span><br><span class="line">        <span class="comment">// 向服务器发送的数据类型</span></span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><br><span class="line">        <span class="comment">//设置请求的方式，后台返回数据流，就要设置 arraybuffer，也可以设置&#x27;blob&#x27;。</span></span><br><span class="line">        <span class="attr">responseType</span>: <span class="string">&quot;arraybuffer&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">            <span class="comment">// 处理返回的文件流（data  是后台返回的数据流） new Blob  里面，type 是要下载的各类文件类型</span></span><br><span class="line">            <span class="keyword">let</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([data], &#123; <span class="attr">type</span>: <span class="string">&quot;content-type接收的文件类型&quot;</span> &#125;);</span><br><span class="line">            <span class="keyword">let</span> objectUrl = (<span class="variable language_">window</span>.<span class="property">URL</span> || <span class="variable language_">window</span>.<span class="property">webkitURL</span>).<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">            <span class="keyword">let</span> downFile = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> fileName = <span class="string">&quot;文件名称&quot;</span>;</span><br><span class="line">            downFile.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">            downFile.<span class="property">href</span> = objectUrl;</span><br><span class="line">            downFile.<span class="property">download</span> = fileName;          <span class="comment">// 下载后文件名，这个不能少，否则浏览器会跳转</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(downFile);</span><br><span class="line">            downFile.<span class="title function_">click</span>();</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(downFile);   <span class="comment">// 下载完成移除元素</span></span><br><span class="line">            <span class="comment">// window.location.href = objectUrl</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(objectUrl); <span class="comment">// 只要映射存在，Blob就不能进行垃圾回收，因此一旦不再需要引用，就必须小心撤销URL，释放掉blob对象。</span></span><br><span class="line">            parent.<span class="property">layer</span>.<span class="title function_">closeAll</span>();<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="content-type类型参考表"><a href="#content-type类型参考表" class="headerlink" title="content-type类型参考表"></a>content-type类型参考表</h2><p>最近做文件下载因为涉及到不同类型的文件，所以重新查阅了一下文件所对应的的content-type类型，好记性不如烂笔头，记录一下。</p><div class="table-container"><table><thead><tr><th>文件后缀</th><th style="text-align:center">MIME TYPE</th></tr></thead><tbody><tr><td>.doc</td><td style="text-align:center">application/msword</td></tr><tr><td>.dot</td><td style="text-align:center">application/msword</td></tr><tr><td>.docx</td><td style="text-align:center">application/vnd.openxmlformats-officedocument.wordprocessingml.document</td></tr><tr><td>.dotx</td><td style="text-align:center">application/vnd.openxmlformats-officedocument.wordprocessingml.template</td></tr><tr><td>.docm</td><td style="text-align:center">application/vnd.ms-word.document.macroEnabled.12</td></tr><tr><td>.dotm</td><td style="text-align:center">application/vnd.ms-word.template.macroEnabled.12</td></tr><tr><td>.xls</td><td style="text-align:center">application/vnd.ms-excel</td></tr><tr><td>.xlt</td><td style="text-align:center">application/vnd.ms-excel</td></tr><tr><td>.xla</td><td style="text-align:center">application/vnd.ms-excel</td></tr><tr><td>.xlsx</td><td style="text-align:center">application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td></tr><tr><td>.xltx</td><td style="text-align:center">application/vnd.openxmlformats-officedocument.spreadsheetml.template</td></tr><tr><td>.xlsm</td><td style="text-align:center">application/vnd.ms-excel.sheet.macroEnabled.12</td></tr><tr><td>.xltm</td><td style="text-align:center">application/vnd.ms-excel.template.macroEnabled.12</td></tr><tr><td>.xlam</td><td style="text-align:center">application/vnd.ms-excel.addin.macroEnabled.12</td></tr><tr><td>.xlsb</td><td style="text-align:center">application/vnd.ms-excel.sheet.binary.macroEnabled.12</td></tr><tr><td>.ppt</td><td style="text-align:center">application/vnd.ms-powerpoint</td></tr><tr><td>.pot</td><td style="text-align:center">application/vnd.ms-powerpoint</td></tr><tr><td>.pps</td><td style="text-align:center">application/vnd.ms-powerpoint</td></tr><tr><td>.ppa</td><td style="text-align:center">application/vnd.ms-powerpoint</td></tr><tr><td>.pptx</td><td style="text-align:center">application/vnd.openxmlformats-officedocument.presentationml.presentation</td></tr><tr><td>.potx</td><td style="text-align:center">application/vnd.openxmlformats-officedocument.presentationml.template</td></tr><tr><td>.ppsx</td><td style="text-align:center">application/vnd.openxmlformats-officedocument.presentationml.slideshow</td></tr><tr><td>.ppam</td><td style="text-align:center">application/vnd.ms-powerpoint.addin.macroEnabled.12</td></tr><tr><td>.pptm</td><td style="text-align:center">application/vnd.ms-powerpoint.presentation.macroEnabled.12</td></tr><tr><td>.potm</td><td style="text-align:center">application/vnd.ms-powerpoint.presentation.macroEnabled.12</td></tr><tr><td>.ppsm</td><td style="text-align:center">application/vnd.ms-powerpoint.slideshow.macroEnabled.12</td></tr><tr><td>.zip</td><td style="text-align:center">application/zip</td></tr><tr><td>.tar</td><td style="text-align:center">application/x-tar</td></tr></tbody></table></div><p>以上总结参考来源(<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fxiaoranzhizhu%2Farticle%2Fdetails%2F70473734">https://blog.csdn.net/xiaoranzhizhu/article/details/70473734</a>)</p><p>接下来再补充一下基础知识</p><h3 id="什么是-Content-type"><a href="#什么是-Content-type" class="headerlink" title="什么是 Content-type"></a>什么是 Content-type</h3><p>Content-type是实体首部字段，用于说明请求或返回的消息是用什么格式进行编码的，在request header和response header里都有存在。 用来向服务器或者浏览器说明传输的文件格式，以便服务器和浏览器按照正确的格式进行解析。在最初的的http post请求只支持application/x-www-form-urlencoded,参数是通过浏览器的url进行传递，但此种方法不支持文件上传，所以后来Content-type 扩充了multipart/form-data类型以支持向服务器发送二进制数据，以及随着后面web应用的日益发展增加了application/json的类型</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 前端流的处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 前端流的处理 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React快速入门</title>
      <link href="/post/f13fd461.html"/>
      <url>/post/f13fd461.html</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>本教程讲解了React的快速入门，不多BB，直接全是干货，请尊重原创，如需转载请备注原创链接！</p><hr><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h2><p>React官网：<a href="https://react.docschina.org/">https://react.docschina.org/</a></p><h3 id="什么是React？"><a href="#什么是React？" class="headerlink" title="什么是React？"></a>什么是React？</h3><p>用官网的一句话概括就是用于构建用户界面的 JavaScript 库</p><p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712084610159.png" alt="image-20220712084610159"></p><h3 id="React的好处是什么？"><a href="#React的好处是什么？" class="headerlink" title="React的好处是什么？"></a>React的好处是什么？</h3><p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712085102954.png" alt="image-20220712085102954"></p><h3 id="React和vue的区别："><a href="#React和vue的区别：" class="headerlink" title="React和vue的区别："></a>React和vue的区别：</h3><p><strong>1、监听数据变化的实现原理不同</strong></p><p>Vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化。</p><p>React默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。为什么React不精确监听数据变化呢？这是因为Vue和React设计理念上的区别，Vue使用的是可变数据，而React更强调数据的不可变，两者没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。</p><p><strong>2、数据流的不同</strong></p><p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712090026315.png" alt="image-20220712090026315"></p><p>Vue1.0中可以实现两种双向绑定：父子组件之间，props可以双向绑定；组件与DOM之间可以通过v-model双向绑定。Vue2.x中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且Vue2.x已经不鼓励组件对自己的 props进行任何修改了。</p><p>React一直不支持双向绑定，提倡的是单向数据流，称之为onChange/setState()模式。不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</p><p><strong>3、HoC和mixins</strong></p><p>Vue组合不同功能的方式是通过mixin，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。比如我们定义的模板怎么被编译的？比如声明的props怎么接收到的？这些都是vue创建组件实例的时候隐式干的事。由于vue默默帮我们做了这么多事，所以我们自己如果直接把组件的声明包装一下，返回一个HoC，那么这个被包装的组件就无法正常工作了。</p><p>React组合不同功能的方式是通过HoC(高阶组件）。React最早也是使用mixins的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了mixinx转而使用HoC。高阶组件本质就是高阶函数，React的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。</p><p><strong>4、组件通信的区别</strong></p><p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712090051265.png" alt="image-20220712090051265"></p><p>Vue中有三种方式可以实现组件通信：父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据；子组件通过事件向父组件发送消息；通过V2.2.0中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。</p><p>React中也有对应的三种方式：父组件通过props可以向子组件传递数据或者回调；可以通过 context 进行跨层级的通信，这其实和 provide/inject 起到的作用差不多。React 本身并不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数，但Vue更倾向于使用事件。在React中我们都是使用回调函数的，这可能是他们二者最大的区别。</p><p><strong>5、模板渲染方式的不同</strong></p><p>在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。</p><p>在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。</p><p>举个例子，说明React的好处：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。</p><p><strong>6、渲染过程不同</strong></p><p>Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p><p>React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。</p><p>如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。</p><p><strong>7、框架本质不同</strong></p><p>Vue本质是MVVM框架，由MVC发展而来；</p><p>React是前端组件化框架，由后端组件化发展而来。</p><p><strong>8、Vuex和Redux的区别</strong></p><p>从表面上来说，store注入和使用方式有一些区别。在Vuex中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store来读取数据。在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。</p><p>从实现原理上来说，最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用Vue的感觉。</p><p><strong>9、React是国际比较主流的MV*框架，而vue是MVVM框架，vue3也是参考了react进行的编写，React可以进行小程序编写</strong></p><h3 id="npx创建脚手架和vue中npm创建脚手架的区别："><a href="#npx创建脚手架和vue中npm创建脚手架的区别：" class="headerlink" title="npx创建脚手架和vue中npm创建脚手架的区别："></a>npx创建脚手架和vue中npm创建脚手架的区别：</h3><p>vue中npm创建脚手架的话只能在当前使用的node版本创建，比如你现在用的是14.6.0，你此时使用npm创建脚手架时只能在当前版本使用，换个版本的node的话只能重新安装，这样容易造成资源的浪费</p><p>React中npx创建脚手架的话会在创建完项目之后把本地的删除掉，好处就是不会造成资源的浪费并且时刻可以保持和官网版本同步</p><blockquote><p>npm创建脚手架命令：npm    i    @vue/cli  -g</p><p>npx创建脚手架命令：npx  create-react-app   项目名称</p></blockquote><h3 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h3><p>JSX就是JS+XML，使用JSX去编写项目就可以直接在JS中直接写HTML代码，如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloMessage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Hello &#123;this.props.name&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">&quot;Taylor&quot;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hello-example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="第一个React项目"><a href="#第一个React项目" class="headerlink" title="第一个React项目"></a>第一个React项目</h2><h3 id="使用脚手架创建"><a href="#使用脚手架创建" class="headerlink" title="使用脚手架创建"></a>使用脚手架创建</h3><p>1、在文件夹下面打开cmd命令窗口：然后输入：npx  create-react-app   项目名称</p><p>2、创建好后用vscode打开，打开一个React项目先看package.json文件，因为在工作中大部人都是接盘侠，README.md文件一般都是被修改了</p><p>3、直接npm run start启动项目，其中run可以省略，但本人推荐写上，因为React项目比较大，所以要稍微等一会，启动后看到下面的图片就意味着你成功了：</p><p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712174326734.png" alt="image-20220712174326734"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis缓存</title>
      <link href="/post/788b6b51.html"/>
      <url>/post/788b6b51.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBtais缓存"><a href="#MyBtais缓存" class="headerlink" title="MyBtais缓存"></a>MyBtais缓存</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>Mybatis的二级缓存其实默认是开启的，但我们需要指定每个mapper的缓存策略二级缓存才会生效，如何不配置缓存策略二级缓存则不生效。</p><h2 id="开启二级缓存与配置缓存策略："><a href="#开启二级缓存与配置缓存策略：" class="headerlink" title="开启二级缓存与配置缓存策略："></a>开启二级缓存与配置缓存策略：</h2><p><strong>开启二级缓存：</strong></p><p>默认是开启的</p><p>首先在全局配置文件 mybatis-configuration.xml 文件中加入如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启二级缓存  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置缓存策略：</strong></p><p>在Mybatis的映射Mapper XML文件中设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到 mapper.xml 文件中就这么一个空标签<cache/>，其实这里可以配置<cache type="org.apache.ibatis.cache.impl.PerpetualCache"/>,PerpetualCache这个类是mybatis默认实现缓存功能的类。我们不写type就使用mybatis默认的缓存，也可以去实现 Cache 接口来自定义缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="执行过程讲解："><a href="#执行过程讲解：" class="headerlink" title="执行过程讲解："></a>执行过程讲解：</h2><h3 id="运行环境："><a href="#运行环境：" class="headerlink" title="运行环境："></a>运行环境：</h3><p>这里我们可以证实Mybtis二级缓存是默认开启的，我们只需要配置缓存策略即可使用二级缓存</p><p><strong>启动类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;SqlMapperConfig.xml&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; byId = mapper.findById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        byId = mapper.findById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>mapper接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>mapper接口映射xml：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.Dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    设置二级缓存策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>MyBatis配置文件：</strong></p><p>没有去开启二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    注意先后顺序--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    通过properties标签使用properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    设置UserMapper中的类型别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.example.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置数据源环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;dataSourceJDBC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceJDBC&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com.mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p>第一次执行mapper.findById(1);</p><p>他会先去获取缓存中的映射方法，如果未获取到则进行创建，并将创建的映射方法存入缓存中</p><p><a href="https://imgtu.com/i/jAHS0K"><img src="https://s1.ax1x.com/2022/06/26/jAHS0K.jpg" alt="jAHS0K.jpg"></a></p><p><strong>执行execute</strong>：</p><p>运行执行器，会先判断当前为什么类型的SQL，如果为SELECT的sql又会分为多结果等等方法，这个为多结果的查询sql所以运行多结果执行方法</p><p><a href="https://imgtu.com/i/jESdqH"><img src="https://s1.ax1x.com/2022/06/26/jESdqH.jpg" alt="jESdqH.jpg"></a></p><p><strong>运行多结果执行器：</strong></p><p>判断当前方法是否有边界索引，没有进行查询</p><p><a href="https://imgtu.com/i/jEpbtI"><img src="https://s1.ax1x.com/2022/06/26/jEpbtI.jpg" alt="jEpbtI.jpg"></a></p><p><strong>SelectList查询方法：</strong></p><p>先获取配置文件中的映射语句，再进行query查询</p><p><a href="https://imgtu.com/i/jEpqht"><img src="https://s1.ax1x.com/2022/06/26/jEpqht.jpg" alt="jEpqht.jpg"></a></p><p><strong>query查询方法（CachingExecutor类）重载方法：</strong></p><p>通过映射语句MappedStatement获取SQL,再进行其他的一些参数生成一个key之后用来获取缓存中的结果值</p><p><a href="https://imgtu.com/i/jEpT7d"><img src="https://s1.ax1x.com/2022/06/26/jEpT7d.jpg" alt="jEpT7d.jpg"></a></p><p><strong>query方法（CachingExecutor类）重载方法：</strong></p><p>判断是否开启了二级缓存，没有二级缓存则进行一级缓存的查询，一级缓存还会进行本地缓存的一个获取，没有才进行数据库查询</p><p>如果开启了二级缓存，则进行二级的一个查询，如果有就进行返回结果，并将结果加入到二级缓存，没有还是进行一个一级缓存的查询</p><p><a href="https://imgtu.com/i/jEpHAA"><img src="https://s1.ax1x.com/2022/06/26/jEpHAA.jpg" alt="jEpHAA.jpg"></a></p><p><strong>一级缓存先是进行一个本地缓存的查询，如果本地缓存没有数据就进行数据库查询，查询后会放入本地缓存</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
          <category> java </category>
          
          <category> 缓存原理 </category>
          
          <category> 持久层框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> java </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 持久层框架 </tag>
            
            <tag> 缓存原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java链式调用</title>
      <link href="/post/f29ac09e.html"/>
      <url>/post/f29ac09e.html</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>本文为CSDN博主「ZmyCoder」的原创文章，本篇仅供学习使用，尊重原创</p><p>原文链接：<a href="https://blog.csdn.net/a14654/article/details/112216242">https://blog.csdn.net/a14654/article/details/112216242</a></p><hr><p>之前接入支付宝支付接口的时候，看到支付宝提供的demo中有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建扫码支付请求builder，设置请求参数</span></span><br><span class="line">        <span class="type">AlipayTradePrecreateRequestBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePrecreateRequestBuilder</span>()</span><br><span class="line">            .setSubject(subject)<span class="comment">//订单主题</span></span><br><span class="line">            .setTotalAmount(totalAmount)<span class="comment">//订单总金额，单位为元</span></span><br><span class="line">            .setOutTradeNo(outTradeNo)<span class="comment">//订单号</span></span><br><span class="line">            .setUndiscountableAmount(undiscountableAmount)<span class="comment">//默认0.0</span></span><br><span class="line">            .setSellerId(sellerId)<span class="comment">//卖家支付宝账号ID</span></span><br><span class="line">            .setBody(body)<span class="comment">//订单描述</span></span><br><span class="line">            .setOperatorId(operatorId)<span class="comment">//商户操作员编号 13688889999</span></span><br><span class="line">            .setStoreId(storeId)<span class="comment">//商户门店编号</span></span><br><span class="line">            .setExtendParams(extendParams)<span class="comment">//业务扩展参数</span></span><br><span class="line">            .setTimeoutExpress(timeoutExpress)<span class="comment">//支付超时</span></span><br><span class="line">            .setNotifyUrl(<span class="string">&quot;http://www.test-notify-url.com&quot;</span>)<span class="comment">//支付宝服务器主动通知商户服务器里</span></span><br><span class="line">               <span class="comment">//指定的页面http路径,根据需要设置</span></span><br><span class="line">            .setGoodsDetailList(goodsDetailList);<span class="comment">//商品明细列表</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><p>当时在开发没顾得上去了解，现在闲了一点，在看<a href="https://so.csdn.net/so/search?q=设计模式&amp;spm=1001.2101.3001.7020">设计模式</a>，今天看到建造者模式，看到代码形态是差不多的，才知道这java链式调用。<br>废话不多说，直接用代码来介绍java链式调用。</p><p>一般，我们在创建javaBean的时候，采用的是new关键字来创建的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">computer.setCPU(<span class="string">&quot;inter-i5&quot;</span>);</span><br><span class="line">computer.setGPU(<span class="string">&quot;GTX-960&quot;</span>);</span><br><span class="line">computer.setMemoryType(<span class="string">&quot;ddr3 1666MHz&quot;</span>);</span><br><span class="line">computer.setMemorySize(<span class="number">8</span>);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>而采用链式调用的写法的话，则是不一样的风格，这种风格更适合人类的思维，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.Builder()</span><br><span class="line">        .setCPU(<span class="string">&quot;inter-skylake-i7&quot;</span>)</span><br><span class="line">        .setGPU(<span class="string">&quot;GTX-Titan&quot;</span>)</span><br><span class="line">        .setMemoryType(<span class="string">&quot;ddr4-2133MHz&quot;</span>)</span><br><span class="line">        .setMemorySize(<span class="number">16</span>)</span><br><span class="line">        .setStorageType(<span class="string">&quot;ssd&quot;</span>)</span><br><span class="line">        .setStorageSize(<span class="number">512</span>)</span><br><span class="line">        .setScreenType(<span class="string">&quot;IPS&quot;</span>)</span><br><span class="line">        .setScreenSize(<span class="number">28</span>)</span><br><span class="line">        .setOSType(<span class="string">&quot;Ubuntu/Window10&quot;</span>)</span><br><span class="line">        .create();</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>下面就是Computer的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String CPU;</span><br><span class="line"><span class="keyword">private</span> String GPU;</span><br><span class="line"><span class="keyword">private</span> String memoryType;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> memorySize;</span><br><span class="line"><span class="keyword">private</span> String storageType;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> storageSize;</span><br><span class="line"><span class="keyword">private</span> String screenType;</span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> screenSize;</span><br><span class="line"><span class="keyword">private</span> String OSType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法私有化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">CPU = builder.CPU;</span><br><span class="line">GPU = builder.GPU;</span><br><span class="line">memoryType = builder.memoryType;</span><br><span class="line">memorySize = builder.memorySize;</span><br><span class="line">storageType = builder.storageType;</span><br><span class="line">storageSize = builder.storageSize;</span><br><span class="line">screenType = builder.screenType;</span><br><span class="line">screenSize = builder.screenSize;</span><br><span class="line">OSType = builder.OSType;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="comment">// Optional parameters - initialize with default values</span></span><br><span class="line"><span class="keyword">private</span> String CPU;</span><br><span class="line"><span class="keyword">private</span> String GPU;</span><br><span class="line"><span class="keyword">private</span> String memoryType;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> memorySize;</span><br><span class="line"><span class="keyword">private</span> String storageType;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> storageSize;</span><br><span class="line"><span class="keyword">private</span> String screenType;</span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> screenSize;</span><br><span class="line"><span class="keyword">private</span> String OSType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供调用入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> niwei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>   2018下午7:34:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Computer <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setCPU</span><span class="params">(String CPU)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.CPU = CPU;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setGPU</span><span class="params">(String GPU)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.GPU = GPU;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setMemoryType</span><span class="params">(String memoryType)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.memoryType = memoryType;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setMemorySize</span><span class="params">(<span class="type">int</span> memorySize)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.memorySize = memorySize;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setStorageType</span><span class="params">(String storageType)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.storageType = storageType;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setStorageSize</span><span class="params">(<span class="type">int</span> storageSize)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.storageSize = storageSize;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setScreenType</span><span class="params">(String screenType)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.screenType = screenType;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setScreenSize</span><span class="params">(<span class="type">float</span> screenSize)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.screenSize = screenSize;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setOSType</span><span class="params">(String OSType)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.OSType = OSType;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充部分：</p><p>先说一下这么写的好处在于一方面可以尽可能的少去类型转换的判定，而且大大增强了代码的阅读性，也就是更符合人类阅读的习惯，同时也减少了代码量。</p><p>下面通过一个小例子来演示一下链式编程：</p><p>public class LinkMan {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式接口调用时，返回值类型和link该对象类型保持一致</span></span><br><span class="line"><span class="comment">//返回值类型为LinkMan</span></span><br><span class="line"><span class="keyword">public</span> LinkMan <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LinkMan <span class="title function_">setTitle</span><span class="params">(String title)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.title = title;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LinkMan <span class="title function_">setAge</span><span class="params">(Integer age)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;name： &quot;</span> + name + <span class="string">&quot; title: &quot;</span> + title + <span class="string">&quot; age: &quot;</span> + age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkMan</span> <span class="variable">linkMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkMan</span>().setName(<span class="string">&quot;NIKE&quot;</span>).setTitle(<span class="string">&quot;测试&quot;</span>).setAge(<span class="number">26</span>);</span><br><span class="line">System.out.println(linkMan.toString());</span><br><span class="line">System.out.println(linkMan.getName());</span><br></pre></td></tr></table></figure><p>输出信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name：</span> <span class="string">NIKE title: 测试  age: 26</span></span><br><span class="line"><span class="attr">NIKE</span></span><br></pre></td></tr></table></figure><p>总结：链式调用有个缺点，一般情况下，JavaBean类中是写getter/setter的，可以使用ide快速生成，而链式调用需要手动写setter部分的代码（可以先用ide生成，然后手动改相关的setter部分代码，通过这种方式来减少工作量），不过只要在Java Bean写完一次，在别的地方调用就方便了很多，有得有失，代码之道啊：）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁的理解</title>
      <link href="/post/b4bbe9af.html"/>
      <url>/post/b4bbe9af.html</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>本文为百度文章高级互联网专家的原创文章，本篇仅供学习使用，尊重原创</p><p>原文链接：<a href="https://baijiahao.baidu.com/s?id=1709427910908845097&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709427910908845097&amp;wfr=spider&amp;for=pc</a></p><hr><h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>InnoDB实现了如下两种标准的行级锁：</p><ul><li><strong>共享锁</strong>（S Lock）：允许事务对一条行数据进行读取</li><li><strong>排他锁</strong>（X Lock）：允许事务对一条行数据进行删除或更新</li></ul><p>如果一个事务T1已经获得了行r的共享锁， 那么另外的事务T2可以立即获得行r的共享锁， 因为读取并没有改变行 r 的数据， 称这种情况为<strong>锁兼容</strong> (Lock Compatible)。 但若有其他的事务T3想获得行r的排他锁， 则其必须等待事务T1, T2释放行r上的共享锁——这种情况称为<strong>锁不兼容</strong>。因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p><p>从上表可以发现，<strong>X锁与任何锁都不兼容，而S锁仅和S锁兼容</strong>。</p><p>此外， InnoDB 存储引擎支持多粒度锁定， 这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支待在不同粒度上进行加锁操作， InnoDB 存储引擎支持 一种额外的锁方式， 称之为<strong>意向锁</strong> (Intention Lock)。意向锁是将锁定的对象分为多个层次， 意向锁意味着事务希望在更细粒度上进行加锁。</p><p>InnoDB存储引擎支持意向锁设计比较简练，其<strong>意向锁即为表级别的锁</strong>。设计目的主要是为了在事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p><ul><li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁</li><li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁</li></ul><p>由于InnoDB存储引擎支持的是行级别的锁，因此<strong>意向锁不会阻塞除全表扫描以外的任何请求</strong>，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。</p><p>如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。</p><p>故表级意向锁和行级锁的兼容性如下表所示：</p><h1 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h1><p>InnoDB有三种行锁的算法：</p><ul><li><p><strong>Record Lock</strong></p><p>简单说就是单个行记录上加锁，防止事务间修改或删除数据。Record Lock总是会去锁住索引记录，如果表建立的时候没有设置任何一个索引，InnoDB存储引擎会使用隐式的主键来进行锁定。</p></li><li><p><strong>Gap Lock</strong></p><p>间隙锁，表示只锁住一段范围，<strong>不锁记录本身</strong>，通常表示两个索引记录之间，或者索引上的第一条记录之前，或者最后一条记录之后的锁。</p></li><li><p><strong>Next-Key Lock</strong></p><p>Gap Lock + Record Lock，锁定一个范围及锁定记录本身。例如一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-key Locking的区间为<code>(负无穷, 10), (10, 11), (11, 13), (12, 20), (20, 正无穷)</code>。需要理解一点，InnoDB中加锁都是给所有记录一条一条加锁，并没有一个直接的范围可以直接锁住，所以会生成多个区间。</p></li></ul><p>MySQL默认情况下使用RR的隔离级别，而<strong>Next-key Lock正是为了解决RR隔离级别下的不可重复读问题和幻读问题</strong>。所谓不可重复读就是一个事务内执行相同的查询，会看到不同的行记录，在RR隔离级别下这是不允许的。</p><p>假设索引上有记录<code>1，4，5，8，12</code>，我们执行类似语句<code>SELECT … WHERE col &gt; 10 FOR UPDATE</code>。如果我们不在<code>(8, 12)</code>之间加上Next-key Lock，另外一个会话就可能向其中插入一条记录9，再执行一次相同的<code>SELECT ... FOR UPDATE</code>，就会看到新插入的记录。这也是为什么MySQL插入一条记录时，需要判断下一条记录上是否加锁了，如果加锁就需要等待。</p><p><strong>InnoDB对行的查询默认采用Next-key算法</strong>。然而，<strong>当查询条件为等值时，且索引有唯一属性时（就是只锁定一条记录），InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock</strong>，即仅锁住索引本身，而不是一个范围，因为此时不会产生重复读问题。</p><h1 id="锁读取"><a href="#锁读取" class="headerlink" title="锁读取"></a>锁读取</h1><blockquote><p><strong>一致性非锁定读</strong>(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVCC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p></blockquote><p><a href="https://imgtu.com/i/jJJdOK"><img src="https://s1.ax1x.com/2022/07/04/jJJdOK.jpg" alt="jJJdOK.jpg"></a></p><p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为<strong>行多版本技术</strong>。由此带来的并发控制，称之为<strong>多版本并发控制</strong>(Multi Version Concurrency Control, MVCC)。**InnoDB是通过undo log来实现MVCC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p><p><strong>一致性非锁定读是InnoDB默认的读取方式</strong>，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p><p>在事务隔别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。</p><p>我们下面举个例子来详细说明一下上述的情况。</p><p><a href="https://imgtu.com/i/jJJ0eO"><img src="https://s1.ax1x.com/2022/07/04/jJJ0eO.jpg" alt="jJJ0eO.jpg"></a></p><p>首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有提交。与此同时，在开启另一个会话B，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。</p><p>由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p><p>当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了：</p><ul><li><strong>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本</strong>，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。</li><li><strong>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据</strong>，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</li></ul><p>在默认情况下，即事务的隔离级别是repeatable read模式下，InnoDB存储引擎的SELECT操作使用的是一致性非锁定读。但是在某些情况下，用户需要显示的读取数据操作进行加锁保证数据逻辑的一致性。</p><p>InnoDB提供了两种方式实现一致性锁定读：</p><ul><li><code>select … for udpate</code>，对读取的行加了X锁</li><li><code>select … lock in share mode</code>，对读取的行加了S锁</li></ul><p>需要注意的是，以上两种语句必须在一个事务当中，当事务提交了，锁也就释放了。</p><h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><blockquote><p>因为不同锁之间的兼容性关系，有时候一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是<strong>阻塞</strong>。</p></blockquote><p>在InnoDB，参数<code>innodb_lock_wait_timeout</code>用来控制等待的时间，<code>innodb_rollback_on_timeout</code>用来设定是否在等待超时后回滚。前者是动态的，后者是静态的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_lock_wait_timeout&#x27;\G;</span><br><span class="line">*************************** 1. row</span><br><span class="line">Variable_name: innodb_lock_wait_timeout</span><br><span class="line">Value: 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;innodb_rollback_on_timeout&#x27;\G;</span><br><span class="line">1. row</span><br><span class="line">: innodb_rollback_on_timeout</span><br><span class="line">Value: OFF</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种相互等待的现象。若无外力作用，事务都将无法推进下去。</p><p>解决死锁做简单的方法就是超时，即当两个事务互相等待时，当一个等待时间超过了某一阈值，其中一个事务进行回滚，另一个等待的事务就能继续进行。</p><p>但是如果超时的事务所占权重比较大，如事务更新了很多行，占用了较多的undo log，回滚这个事务的时间相对于另一个事务所占用的时间可能会更多，就显得不合适了。</p><p>因此，除了超时机制，当前数据库都普遍采用<strong>等待图</strong>（wait-for graph）的方式来进行死锁检测。</p><p>wait-for graph要求数据库保存以下两种信息:</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在 wait-for graph中,事务为图中的节点。而在图中,事务T1指向T2边的定义为:</p><ul><li>事务T1等待事务T2所占用的资源</li><li>事务T1最终等待T2所占用的资源,也就是事务之间在等待相同的资源,而事务T1发生在事务T2的后面</li></ul><p>来看一个例子：</p><p><a href="https://imgtu.com/i/jJJay6"><img src="https://s1.ax1x.com/2022/07/04/jJJay6.jpg" alt="jJJay6.jpg"></a></p><p>在 Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4,故在wait-for graph中应有4个节点。</p><p><a href="https://imgtu.com/i/jJJUQx"><img src="https://s1.ax1x.com/2022/07/04/jJJUQx.jpg" alt="jJJUQx.jpg"></a></p><p>通过上图可以发现存在回路(t1,t2)，因此存在死锁。可以发现wait-for graph是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。</p><h1 id="InnoDB锁相关状态查询"><a href="#InnoDB锁相关状态查询" class="headerlink" title="InnoDB锁相关状态查询"></a>InnoDB锁相关状态查询</h1><p>用户可以使用<code>INFOMATION_SCHEMA</code>库下的<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来监控当前事务并分析可能出现的锁问题。的关键字段如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;</span><br><span class="line">************************************* 1.row *********************************************</span><br><span class="line">trx_id: 7311F4</span><br><span class="line">trx_state: LOCK WAIT</span><br><span class="line">trx_started: 2010-01-04 10:49:33</span><br><span class="line">trx_requested_lock_id: 7311F4:96:3:2</span><br><span class="line">trx_wait_started: 2010-01-04 10:49:33</span><br><span class="line">trx_weight: 2</span><br><span class="line">trx_mysql_thread_id: 471719</span><br><span class="line">trx_query: select * from parent lock in share mode</span><br></pre></td></tr></table></figure><p>表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表，该表的关键字段组成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM.INNODB_LOCKS\G;</span><br><span class="line">1. row</span><br><span class="line">lock_id: 16219:56:4:5</span><br><span class="line">lock_trx_id: 16219</span><br><span class="line">lock_mode: X,GAP</span><br><span class="line">lock_type: RECORD</span><br><span class="line">lock_table: `test`.`z`</span><br><span class="line">lock_index: b</span><br><span class="line">lock_space: 56</span><br><span class="line">lock_page: 4</span><br><span class="line">lock_rec: 5</span><br><span class="line">lock_data: 6, 7</span><br><span class="line">2. row</span><br><span class="line">lock_id: 16218:56:4:5</span><br><span class="line">: 16218</span><br><span class="line">lock_mode: X,GAP</span><br><span class="line">lock_type: RECORD</span><br><span class="line">lock_table: `test`.`z`</span><br><span class="line">lock_index: b</span><br><span class="line">lock_space: 56</span><br><span class="line">lock_page: 4</span><br><span class="line">lock_rec: 5</span><br><span class="line">lock_data: 6, 7</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM.INNODB_LOCK_WAITS\G;</span><br><span class="line">*******************************************1.row************************************</span><br><span class="line">requesting_trx_id: 7311F4</span><br><span class="line">requesting_lock_id: 7311F4:96:3:2</span><br><span class="line">blocking_trx_id: 730FEE</span><br><span class="line">blocking_lock_id: 730FEE:96:3:2</span><br></pre></td></tr></table></figure><p>通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。</p><h1 id="锁的应用实例解析"><a href="#锁的应用实例解析" class="headerlink" title="锁的应用实例解析"></a>锁的应用实例解析</h1><p>有一点需要特别注意，MySQL怎么使用锁，与事务的隔离级别、列上的索引状况等密切相关。单拎出一条SQL语句来讨论加锁的方式以及范围而不考虑使用场景，都是耍流氓的行为。</p><p>下面就不同场景下锁的使用情况做一下对比，深入理解上面的理论知识。</p><h2 id="场景1：RR隔离级别-主键索引"><a href="#场景1：RR隔离级别-主键索引" class="headerlink" title="场景1：RR隔离级别+主键索引"></a>场景1：RR隔离级别+主键索引</h2><p>首先根据如下代码创建测试表t，然后开启两个事务进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t(a int primary key);</span><br><span class="line">insert into t select 1;</span><br><span class="line">insert into t select 2;</span><br><span class="line">insert into t select 5;</span><br><span class="line">insert into t select 7;</span><br><span class="line">insert into t select 9;</span><br></pre></td></tr></table></figure><p>开启事务1，保持未提交的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where a=5 for update;</span><br></pre></td></tr></table></figure><p>开启事务2并提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t select 4;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>表t共有1、2、5、7、9五个值，在上面的例子中，在事务1中首先对<code>a=5</code>进行X锁定，而由于a是主键且唯一，因此锁定的仅是5这个值，而不是（2,5）这个范围。这样在事务2中插入值4而不会阻塞，可以立即插入并返回。即锁定由Next-key Lock算法降级为Record Lock，从而提高应用的并发性。</p><p>需要意的一点是，对于唯一键值的锁定，<strong>Next-Key Lock降级为Record Lock仅存在于查询所有的唯一索引列</strong>。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是range类型查询，而不是const类型查询，故InnoDB存储引擎依然使用Next-Key Lock进行锁定。</p><p>但如果对主键进来范围查询时，锁的范围是怎么样的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where a&lt;=5 for update;</span><br></pre></td></tr></table></figure><p>针对下面的sql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into test.t select 6;</span><br><span class="line">insert into test.t select 8</span><br></pre></td></tr></table></figure><p>第一条会产生锁等待，而第二条可以插入成功。</p><p>表t共有1、2、5、7、9五个值，在上面的例子中，在事务1中执行<code>a&lt;=5</code>范围查询时，事务1加锁范围是<code>(负无穷, 1)、(1, 2)、(2, 5)、(5, 7)</code>，且<code>1、2、5、7</code>这四条记录也都加锁了，也就是说再插入<code>&lt;=7</code>的记录都是会产生锁等待，插入记录8是成功的。</p><p>那么InnoDB如何判断是否允许插入数据呢？对于普通索引，insert的加锁策略是：查找小于等于 insert_rec 的第一条记录，然后查看第一条记录的下一个记录是否有Gap锁，有则等待，没有则插入。比如说我们插入6这条记录，首先定位<code>&lt;=6</code>的记录，也就是5，然后确认5的下一条记录是否锁住了Gap，这里也就是7，当7这条记录有锁是代表锁住的是<code>(5, 7)</code>这个范围，就不允许插入（会申请一把插入意向锁），保证了可重复读。证明了在RR隔离级别下使用了Next-key Lock来保证其“可重复读”的特性。如果没有锁就直接插入即可。</p><p>但是如果插入的记录有唯一约束时，只判断下一条记录是否锁住了Gap就不行了，显然会插入重复数据破坏唯一性。这时还会把插入的记录与前一条数据进行比较，如果相同则给插入记录的前一条记录加S Lock（lock in share mode），加锁成功则返回duplicate key，否则等待S Lock。</p><p>这个地方可能有人会有一个疑问，为什么MySQL在加锁时，不直接加5这条记录本身以及&lt;5的记录呢？为什么还要给加锁呢？因为(5, 7)加不加锁并不会影响RR级别可重复读的特性。其实这就跟B+树有关系了，首先MySQL定位到1这条记录并加锁，然后顺着1往后读取数据并加锁，直到读取到第一条不匹配数据才能确定是否停止继续读取数据，而在RR隔离级别下只要被读到的数据都需要进行加锁。如果查询条件是&lt;5，那么加锁只会加到5这条记录为止。</p><p>如果是在RC隔离级别下，只会对符合条件的记录进行加记录锁，不会对满足条件的下一条记录进行加锁。</p><h2 id="场景2：RR隔离级别-普通索引"><a href="#场景2：RR隔离级别-普通索引" class="headerlink" title="场景2：RR隔离级别+普通索引"></a>场景2：RR隔离级别+普通索引</h2><p>正如上面所介绍的，Next-Key Lock降级为Record Lock仅在查询的列是唯一索引且条件为等值查询的情况下。若是辅助索引，则情况会完全不同，</p><p>首先根据如下代码创建测试表z：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table z(id int primary key,b int,index(b));</span><br><span class="line">insert into z values(1,1);</span><br><span class="line">insert into z values(3,1);</span><br><span class="line">insert into z values(5,3);</span><br><span class="line">insert into z values(7,6);</span><br><span class="line">insert into z values(10,8);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where b=3 for update;</span><br></pre></td></tr></table></figure><p>这时SQL语句通过索引列b进行查询，因此其使用传统的Next-key Locking技术加锁，并且由于有两个索引，其需要分别进行锁定。对于聚集索引，其仅对列id等于5的索引加上Record Lock。那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 z 表进行更新，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。</p><p>而对于辅助索引，其加上的是Next-key Lock，锁定的范围是（1, 3），特别需要注意的是，InnoDB存储引擎还会对辅助索引下一个键值加上Gap lock，即还有一个辅助索引范围为（3, 6）的锁。</p><p>此时，若在新的事务2中运行下面的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from z where id=5 lock in share mode;</span><br><span class="line">insert into z select 2,1;</span><br><span class="line">insert into z select 4,2;</span><br><span class="line">insert into z select 6,6;</span><br></pre></td></tr></table></figure><p>第一个SQL语句，在事务1中执行的SQL语句已经对聚集索引中的列“a=5”的值加上X锁，因此执行会被阻塞。</p><p>第二SQL语句，主键插入2，没有问题，插入的辅助索引值1也不在锁定的范围（1,3）中，因此可以执行成功。</p><p>第三个SQL语句，主键插入4，没有问题，插入的辅助索引值2在锁定的范围（1,3）中，因此执行会被阻塞。</p><p>第四个SQL语句，插入的主键6没有被锁定，6也不在范围（1,3）之间。但插入的值6在另一个锁定的范围（3,6）中，故同样需要等待。</p><p>在RR隔离级别下，对于INSERT的操作，其会检查插入记录的下一条记录是否被锁定，若已经被锁定，则不允许操作，从而避免不可重复读问题。而下面的SQL语句，不会被阻塞，可以立即执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into z select 8,6;</span><br><span class="line">insert into z select 2,0;</span><br><span class="line">insert into z select 6,7;</span><br></pre></td></tr></table></figure><p>从上面的例子中可以看到，Gap Lock的作用是为了阻止多个事务将记录插入到同一个范围内，解决“不可重复读”问题的产生。例如在上面的例子中，事务1中用户已经锁定了b=3的记录，若此时没有Gap Lock锁定<code>(3, 6)</code>，那么用户可以插入索引b列为3的记录，这会导致事务1中的用户再次执行同样的查询时会返回不同的记录，即产生不可重复读问题。</p><p>这里有一个问题值得思考一下，为什么插入<code>(6, 6)</code>不允许，而插入<code>(8, 6)</code>是允许的。这跟InnoDB索引结构有关系，我们知道二级索引是指向主键，所以结构如：<code>(1, 1), (1, 3), (3, 5), (6, 7), (8, 10)</code>。真正的Gap锁锁住的也是<code>((1, 1), (1, 3))</code>这样的结构，所以当我们插入<code>(6, 6)</code>时，需要插入到<code>(3, 5), (6, 7)</code>之间，这区间被锁，所以无法插入；而我们插入<code>(8, 6)</code>是需要插入到<code>(6, 7), (8, 10)</code>之间，没有锁存在，所以可以插入成功。</p><p>另外，在RR隔离级别下，我们访问条件为二级索引的情况下，就算访问一条不存在的记录同样需要加Next-key Lokcs，比如我们查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from z where b=7 for update;</span><br></pre></td></tr></table></figure><p>InnoDB会对(6, 8)这个区间加了Gap Lock，也就是说插入这个区间的数据都会被阻塞。</p><p>虽然在RR隔离级别默认使用Gap Lock，但用户可以通过以下两种方式来显式地关闭Gap Lock：</p><ul><li>将事务的隔离级别设置为READ COMMITTED；</li><li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1；</li></ul><p>当设置了上述参数或隔离级别调整到<strong>READ COMMITTED</strong>时，除了外键约束和唯一性检查（duplicate key）依然需要Gap Lock，其余情况仅使用Record Lock进行锁定。但需要知道的是，上述设置破坏了事务的隔离性，并且对于MySQL复制来说，可能会导致主从数据的不一致。虽然MySQL目前默认隔离级别是RR，但是基本生产环境标配基本都是RC隔离级别+ROW格式。</p><h2 id="场景3：RC隔离级别-主键索引"><a href="#场景3：RC隔离级别-主键索引" class="headerlink" title="场景3：RC隔离级别+主键索引"></a>场景3：RC隔离级别+主键索引</h2><p>将事务隔离级别切为RC，开启事务1，保持未提交的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where id&gt;3 for update;</span><br></pre></td></tr></table></figure><p>执行下面的SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into z select 6,6;</span><br></pre></td></tr></table></figure><p>可以执行成功。证明在事务1执行主键范围for update时，事务2对这个范围扔可以申请写锁。证明RC隔离级别没有使用NEXT-KEY Lock，而是使用行级锁锁住对应的记录。</p><h2 id="场景4：RC隔离级别-普通索引"><a href="#场景4：RC隔离级别-普通索引" class="headerlink" title="场景4：RC隔离级别+普通索引"></a>场景4：RC隔离级别+普通索引</h2><p>将事务隔离级别切为RC，开启事务1，保持未提交的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where b&gt;3 for update;</span><br></pre></td></tr></table></figure><p>此时，若在新的事务2中运行下面的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into z select 8,4;</span><br><span class="line">update z set b = 10 where b = 6;</span><br><span class="line">update z set b = 10 where b = 1;</span><br></pre></td></tr></table></figure><p>第一个SQL语句，插入数据到事务1的for update范围内是可以的，因为这里事务1在RC模式下没有加NEXT-KEY LOCK锁，所以可以插入数据。</p><p>第二个SQL语句，会出现锁等待，我们选择普通索引作为条件，此时MySQL给普通索引b&gt;3的记录都会加行锁。同时，这些记录对应主键索引上的记录也都加上了锁</p><p>第三个SQL语句，插入成功，说明b&lt;3的记录都无锁。</p><h2 id="场景5：RR-无索引"><a href="#场景5：RR-无索引" class="headerlink" title="场景5：RR + 无索引"></a>场景5：RR + 无索引</h2><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的</strong>，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将会给所有记录加锁</strong>。</p><p>在RR隔离级别下，由于查询条件没有索引，那么InnoDB需要扫描所有数据来查找数据，对于扫描过的数据InnoDB都会加上锁，并且是加Next-key lock。</p><p>建立测试表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tab_no_index(id int,b int) engine=innodb;</span><br><span class="line">insert into tab_no_index values(1,1),(2,2),(3,3),(4,4),(100,100);</span><br></pre></td></tr></table></figure><p>开启事务1，保持未提交的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tab_no_index where id = 1 for update;</span><br></pre></td></tr></table></figure><p>执行下面的SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tab_no_index values(5,5);</span><br></pre></td></tr></table></figure><p>这时候，并不能插入成功。看起来事务1只给一行加了排他锁，但事务2在请求其他行的排他锁时，却出现了锁等待。原因就在于没有索引的情况下，InnoDB只能扫描所有记录（锁住所有记录）。当我们给其增加一个唯一索引后，InnoDB就只锁定了符合条件的行。</p><p>当我们给其增加一个唯一索引后，InnoDB就只锁定了符合条件的行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tab_with_index(id int,b int,primary key(id));</span><br><span class="line">insert into tab_with_index values(1,1),(2,2),(3,3),(4,4),(100,100);</span><br></pre></td></tr></table></figure><p>开启事务1，保持未提交的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tab_with_index where id = 1 for update;</span><br></pre></td></tr></table></figure><p>执行下面的SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tab_with_index where id = 2 for update;</span><br></pre></td></tr></table></figure><p>由这个例子可以看出，对于id是主键索引的情况下，只锁了id=1这一行记录。其余的行都是可以进行DML操作的，但前提条件是以id为条件。如果是以b字段为条件，那么还是会锁的。</p><h2 id="场景6：RC-无索引"><a href="#场景6：RC-无索引" class="headerlink" title="场景6：RC + 无索引"></a>场景6：RC + 无索引</h2><p>上面演示了在RR隔离级别下，对于where条件无索引的情况下，InnoDB是对所有记录加Next-key Locks。</p><p>但是在RC隔离级别下，对于where条件无索引的情况下，则不会对所有记录加锁，而是只对命中的数据的聚簇索引加X锁。</p><p>同样针对tab_no_index``表，开启事务1，保持未提交的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">delete from tab_no_index where id = 1;</span><br></pre></td></tr></table></figure><p>执行下面的SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from tab_no_index where id = 99;</span><br><span class="line">update tab_no_index set id=2 where id=100;</span><br><span class="line">insert into tab_no_index select 99,99;</span><br></pre></td></tr></table></figure><p>都可以执行成功。</p><h2 id="沙场练兵"><a href="#沙场练兵" class="headerlink" title="沙场练兵"></a>沙场练兵</h2><p>有了上面的分场景演习，下面就两条简单SQL进行一场加锁分析的实战。</p><p>下面两条简单的SQL，加什么锁？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where id = 10;</span><br><span class="line">delete from t1 where id = 10;</span><br></pre></td></tr></table></figure><p>一眼看去，不经大脑的回答是：</p><ul><li>SQL1：不加锁。因为MySQL是使用多版本并发控制的，读不加锁</li><li>SQL2：对id = 10的记录加写锁 (走主键索引)</li></ul><p>可能是正确的，也有可能是错误的，已知条件不足，要回答这个问题，还缺少几个前提条件：</p><ul><li>id列是不是主键？</li><li>当前系统的隔离级别是什么？</li><li>id列如果不是主键，那么id列上有索引吗？</li><li>id列上如果有二级索引，那么这个索引是唯一索引吗？</li></ul><p><strong>组合一：id列是主键，RC隔离级别</strong></p><p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：<code>delete from t1 where id = 10;</code> 只需要将主键上，id = 10的记录加上X锁即可。</p><p><a href="https://imgtu.com/i/jJJTYj"><img src="https://s1.ax1x.com/2022/07/04/jJJTYj.jpg" alt="jJJTYj.jpg"></a></p><p><strong>组合二：id唯一索引+RC</strong></p><p>id是unique索引，而主键是name列。由于id是unique索引，因此delete语句会选择id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。</p><p>为什么聚簇索引上的记录也要加锁？如果并发的一个SQL，是通过主键索引来更新：<code>update t1 set id = 100 where name = ‘d’;</code> 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><p>若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p><p><a href="https://imgtu.com/i/jJJL60"><img src="https://s1.ax1x.com/2022/07/04/jJJL60.jpg" alt="jJJL60.jpg"></a></p><p><strong>组合三：id非唯一索引+RC</strong></p><p>相对于组合一、二，id列不再唯一，只有一个普通的索引。</p><p>满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p><p><a href="https://imgtu.com/i/jJJbpn"><img src="https://s1.ax1x.com/2022/07/04/jJJbpn.jpg" alt="jJJbpn.jpg"></a></p><p><strong>组合四：id无索引+RC</strong></p><p>这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？换句话说，全表扫描时，会加什么锁？</p><p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><p><a href="https://imgtu.com/i/jJJqlq"><img src="https://s1.ax1x.com/2022/07/04/jJJqlq.jpg" alt="jJJqlq.jpg"></a></p><p>为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录都锁上了。</p><p>在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p><p><strong>组合五：id主键+RR</strong></p><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。</p><p>id列是主键列，Repeatable Read隔离级别，针对<code>delete from t1 where id = 10;</code> 这条SQL，加锁与组合一：[id主键，Read Committed]一致。</p><p><strong>组合六：id唯一索引+RR</strong></p><p>与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p><p><strong>组合七：id非唯一索引+RR</strong></p><p>RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。那么RR隔离级别下，如何防止幻读呢？</p><p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行<code>delete from t1 where id = 10;</code> 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？</p><p><a href="https://imgtu.com/i/jJJ7fs"><img src="https://s1.ax1x.com/2022/07/04/jJJ7fs.jpg" alt="jJJ7fs.jpg"></a></p><p>相对于组合三：[id列上非唯一锁，Read Committed]看似相同，其实却有很大的区别。</p><p>最大的区别在于，多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，是加载两条记录之间的位置，GAP锁有何用？</p><p><strong>这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键</strong>。</p><p>GAP锁锁住的位置，不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读(例如：<code>select * from t1 where id = 10 for update;</code>)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p><p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间、[10,b]与[10,d]间、[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。</p><p>因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p><p>Insert操作，如insert [10,a]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p><p>既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？ GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。</p><p>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：<code>delete from t1 where id = 10;</code>首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p><p><strong>组合八：id无索引+RR</strong></p><p>id列上没有索引。此时SQL：<code>delete from t1 where id = 10;</code>没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p><p><a href="https://imgtu.com/i/jJJOXV"><img src="https://s1.ax1x.com/2022/07/04/jJJOXV.jpg" alt="jJJOXV.jpg"></a></p><p>这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p><p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p><p>当然，跟组合四：[id无索引, Read Committed]类似，这个情况下，MySQL也做了一些优化，就是所谓的<code>semi-consistent read</code>。<code>semi-consistent read</code>开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。</p><p>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发<code>semi-consistent read</code>，来缓解加锁开销与并发影响，但是<code>semi-consistent read</code>本身可能会带来其他问题。</p><p><strong>组合九：Serializable</strong></p><p>Serializable隔离级别。对于SQL2：<code>delete from t1 where id = 10;</code> 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致</p><p>Serializable隔离级别，影响的是SQL1：<code>select * from t1 where id = 10;</code>这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p><p>MVCC 最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC</p><p>在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL锁进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus快速入门</title>
      <link href="/post/efc815e8.html"/>
      <url>/post/efc815e8.html</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>本教程是根据B站Up主狂神说记得笔记，有需要查看视频的小伙伴可以去看看狂神的视频，真的非常好！</p><p>狂神说MybatisPlus视频地址：<a href="https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p><hr><h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="MyBatisPlus概述"><a href="#MyBatisPlus概述" class="headerlink" title="MyBatisPlus概述"></a>MyBatisPlus概述</h2><p> 需要的基础：MyBatis、Spring、SpringMVC </p><p>为什么要学习它呢？</p><ul><li>MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！ </li></ul><p>市面上主流的一些框架：</p><ul><li>JPA：国外使用的较多，集成springboot时使用较多</li><li>tk-mapper：开源项目使用较多</li><li>MyBatisPlus：国内较为主流的框架</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a> MyBatis Plus，简化 MyBatis ！</p><p><a href="https://imgtu.com/i/jYWy0U"><img src="https://s1.ax1x.com/2022/07/05/jYWy0U.png" alt="jYWy0U.png"></a></p><p><a href="https://imgtu.com/i/jYWB60"><img src="https://s1.ax1x.com/2022/07/05/jYWB60.png" alt="jYWB60.png"></a></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求，以后简单的CRUD操作，都不用自己编写 了！</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>官方地址：<a href="https://baomidou.com/pages/226c21/#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">https://baomidou.com/pages/226c21/#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B</a></p><p>使用第三方组件的四步曲：</p><ol><li>导入对应的依赖</li><li>研究依赖如何配置</li><li>代码如何编写</li><li>提高扩展技术能力！</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>创建名为mybaits_plus数据库</p></li><li><p>根据官网提供的数据创建user表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br><span class="line"><span class="comment">-- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个springboot项目</p></li><li><p>导入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis_plus,导了就不需要导入mybatis了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--这个版本原生较多，最新版查看官方文档即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：我们使用 mybatis-plus 可以节省我们大量的代码</p><p>注意：尽量不要同时导入 mybatis 和 mybatis-plus！容易产生版本差异</p></li><li><p>连接数据库，这里我们使用yaml文件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动：com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动：com.mysql.cj.jdbc.Driver、需要增加时区的配置：serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">Apathy99977</span></span><br><span class="line">    <span class="comment"># 假如时区报错了，就增加一个时区的配置就ok：serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/连接的数据库?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>使用mybatis-plus</p><ol><li><p>编写pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atapathy.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atapathy.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Apathy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 9:53:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在对应的Mapper上面继承基本的类 BaseMapper&lt;要编写sql语句的类&gt;</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 所有的CRUD操作都已经编写完成了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试使用</p><ul><li><p>注意我们需要在主启动类上去扫描我们的mapper包下的所有接口</p><p><a href="https://imgtu.com/i/jYWsmT"><img src="https://s1.ax1x.com/2022/07/05/jYWsmT.png" alt="jYWsmT.png"></a></p></li><li><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlusApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">// 继承了BaseMapper，所有的方法都来自己父类</span></span><br><span class="line">    <span class="comment">// 我们也可以编写自己的扩展方法！</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 参数是一个 Wrapper ，条件构造器，这里我们先不用 null</span></span><br><span class="line">        <span class="comment">// 查询全部用户</span></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><p><a href="https://imgtu.com/i/jYW67F"><img src="https://s1.ax1x.com/2022/07/05/jYW67F.png" alt="jYW67F.png"></a></p></li></ul></li></ol></li></ol><h3 id="思考问题？"><a href="#思考问题？" class="headerlink" title="思考问题？"></a>思考问题？</h3><ol><li>SQL谁帮我们写的 ?         是MyBatis-Plus 写好了的</li><li>方法哪里来的？    MyBatis-Plus 编写的</li></ol><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p><a href="https://imgtu.com/i/jYWDXV"><img src="https://s1.ax1x.com/2022/07/05/jYWDXV.png" alt="jYWDXV.png"></a></p><p>在yaml文件配置的时候可以发现可以配置很多日志类，<strong>StdOutImpl</strong>为默认控制台输出，使用其他类导入相关依赖即可</p><h2 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h2><h3 id="Insert插入"><a href="#Insert插入" class="headerlink" title="Insert插入"></a>Insert插入</h3><p><a href="https://imgtu.com/i/jYWh11"><img src="https://s1.ax1x.com/2022/07/05/jYWh11.png" alt="jYWh11.png"></a></p><p>数据库插入的id的默认值为：全局的唯一id</p><h4 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h4><p>默认 <strong>ID_WORKER</strong> 全局唯一id</p><p>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><h5 id="雪花算法："><a href="#雪花算法：" class="headerlink" title="雪花算法："></a>雪花算法：</h5><ul><li>snowflake是<strong>Twitter</strong>开源的分布式ID生成算法，结果是一个<strong>long型</strong>的ID。</li><li>其核心思想是：使用41bit作为 毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味 着每个节点在每毫秒可以产生 4096 个 ID）</li><li>最后还有一个符号位，永远是0，可以保证几乎全球唯 一！</li></ul><h5 id="注解自增："><a href="#注解自增：" class="headerlink" title="注解自增："></a>注解自增：</h5><p>配置主键自增：</p><ol><li><p>实体类字段上加@TableId(type = IdType.AUTO)zhujie</p></li><li><p>数据库设置时字段一定也要是自增</p><p><a href="https://imgtu.com/i/jYWgk4"><img src="https://s1.ax1x.com/2022/07/05/jYWgk4.png" alt="jYWgk4.png"></a></p></li></ol><h5 id="不同的主键策略："><a href="#不同的主键策略：" class="headerlink" title="不同的主键策略："></a>不同的主键策略：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdType</span> &#123;</span><br><span class="line">    AUTO(<span class="number">0</span>), <span class="comment">// 数据库id自增</span></span><br><span class="line">    NONE(<span class="number">1</span>), <span class="comment">// 未设置主键</span></span><br><span class="line">    INPUT(<span class="number">2</span>), <span class="comment">// 手动输入,一旦手动输入id之后，就需要自己配置id 了</span></span><br><span class="line">    ID_WORKER(<span class="number">3</span>), <span class="comment">// 默认的全局唯一id</span></span><br><span class="line">    UUID(<span class="number">4</span>), <span class="comment">// 全局唯一id uuid</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>); <span class="comment">//ID_WORKER 字符串表示法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">// 通过条件自动拼接动态sql</span></span><br><span class="line">    user.setId(<span class="number">1534360852678524929L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="comment">// 注意：updateById 的参数是一个对象！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(result);<span class="comment">//受影响的行数</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/jYW5X6"><img src="https://s1.ax1x.com/2022/07/05/jYW5X6.png" alt="jYW5X6.png"></a></p><p>所有的sql都是自动帮你动态配置的！</p><h4 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h4><p>创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！ </p><p>阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需 要自动化！</p><h5 id="方式一：数据库级别"><a href="#方式一：数据库级别" class="headerlink" title="方式一：数据库级别"></a>方式一：数据库级别</h5><p>前言：实际工作中一般不允许你修改数据库</p><p>使用方式：</p><ol><li><p>在表中新增字段 create_time, update_time</p><p><a href="https://imgtu.com/i/jYWRh9"><img src="https://s1.ax1x.com/2022/07/05/jYWRh9.png" alt="jYWRh9.png"></a></p></li><li><p>再次测试插入方法，注意需要先把实体类同步！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure></li><li><p>再次更新查看结果即可</p><p><a href="https://imgtu.com/i/jYWfpR"><img src="https://s1.ax1x.com/2022/07/05/jYWfpR.png" alt="jYWfpR.png"></a></p></li></ol><h5 id="方式二：代码级别"><a href="#方式二：代码级别" class="headerlink" title="方式二：代码级别"></a>方式二：代码级别</h5><ol><li><p>删除数据库的默认值、更新操作！</p><p><a href="https://imgtu.com/i/jYW46x"><img src="https://s1.ax1x.com/2022/07/05/jYW46x.png" alt="jYW46x.png"></a></p></li><li><p>实体类字段属性上需要增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字段添加填充内容</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure></li><li><p>编写处理器来处理这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atapathy.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log4j</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 一定不要忘记把处理器加到IOC容器中！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 插入时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill.....&quot;</span>);</span><br><span class="line">        <span class="comment">// setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill.....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试添加和更新然后观察时间</p><p><a href="https://imgtu.com/i/jYWonK"><img src="https://s1.ax1x.com/2022/07/05/jYWonK.png" alt="jYWonK.png"></a></p></li></ol><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！</p><blockquote><p>乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题， 再次更新值测试 </p><p>悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！</p></blockquote><p>当要更新一条记录的时候，希望这条记录没有被别人更新<br>乐观锁实现方式:</p><blockquote><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果 version 不对，就更新失败</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">乐观锁：<span class="number">1</span>、先查询，获得版本号 version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- A线程</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;Gods&quot;, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;Gods&quot;, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="测试一下MybatisPlus的乐观锁插件："><a href="#测试一下MybatisPlus的乐观锁插件：" class="headerlink" title="测试一下MybatisPlus的乐观锁插件："></a>测试一下MybatisPlus的乐观锁插件：</h4><ol><li><p>给数据库中增加version字段！</p><p><a href="https://imgtu.com/i/jYWT0O"><img src="https://s1.ax1x.com/2022/07/05/jYWT0O.png" alt="jYWT0O.png"></a></p></li><li><p>实体类添加对应的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span> <span class="comment">//乐观锁Version注解</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure></li><li><p>注册组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atapathy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atapathy.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    最新版MybatisPlus注册乐观锁插件，因为乐观锁配置(OptimisticLockerInterceptor已经弃用)</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return interceptor;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试乐观锁成功！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOptimisticLocker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、查询用户信息</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 2、修改用户信息</span></span><br><span class="line">    user.setName(<span class="string">&quot;Gods&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;gods@qq.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、执行更新操作</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">    <span class="comment">//查询修改后的值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：发现查询语句的where条件自动帮我们添加了version判断</p><p><a href="https://imgtu.com/i/jYW77D"><img src="https://s1.ax1x.com/2022/07/05/jYW77D.png" alt="jYW77D.png"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试乐观锁失败！多线程下</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOptimisticLocker2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 线程 1</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;Gods1&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;gods@qq.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 模拟另外一个线程执行了插队操作</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;Gods2&quot;</span>);</span><br><span class="line">    user2.setEmail(<span class="string">&quot;gods@qq.com&quot;</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line">    <span class="comment">// 自旋锁来多次尝试提交！</span></span><br><span class="line">    userMapper.updateById(user); <span class="comment">// 如果没有乐观锁就会覆盖插队线程的值！</span></span><br><span class="line">    <span class="comment">//查询修改后的值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>结果：可以发现结果为Gods2</p><p><a href="https://imgtu.com/i/jYWbAe"><img src="https://s1.ax1x.com/2022/07/05/jYWbAe.png" alt="jYWbAe.png"></a></p></li></ul></li></ol><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="测试Id查询"><a href="#测试Id查询" class="headerlink" title="测试Id查询"></a>测试Id查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><a href="https://imgtu.com/i/jYWqtH"><img src="https://s1.ax1x.com/2022/07/05/jYWqtH.png" alt="jYWqtH.png"></a></p><h4 id="测试批量查询"><a href="#测试批量查询" class="headerlink" title="测试批量查询"></a>测试批量查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchId</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：注意查看sql语句</p><p><a href="https://imgtu.com/i/jYWLhd"><img src="https://s1.ax1x.com/2022/07/05/jYWLhd.png" alt="jYWLhd.png"></a></p><h4 id="按条件查询：使用map操作"><a href="#按条件查询：使用map操作" class="headerlink" title="按条件查询：使用map操作"></a>按条件查询：使用map操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 自定义查询</span></span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">17</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：注意查看SQL语句</p><p><a href="https://imgtu.com/i/jYWX9A"><img src="https://s1.ax1x.com/2022/07/05/jYWX9A.png" alt="jYWX9A.png"></a></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>分页在网站使用的频率十分之多！</p><p>使用分页的几种方法</p><ol><li>原始的 limit 进行分页 </li><li>pageHelper 第三方插件 </li><li>MybatisPlus内置的分页插件！</li></ol><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol><li><p>配置拦截器组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新版MybatisPlus分页插件</span></span><br><span class="line"><span class="comment">// 分页插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>直接使用Page对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 参数一：当前页</span></span><br><span class="line">    <span class="comment">// 参数二：页面大小</span></span><br><span class="line">    <span class="comment">// 使用了分页插件之后，所有的分页操作也变得简单的！</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page,<span class="literal">null</span>);</span><br><span class="line">    List&lt;User&gt; records = page.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//获取总数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    System.out.println(<span class="string">&quot;页面总数：&quot;</span>+total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：注意查看SQL语句</p><p><a href="https://imgtu.com/i/jYWvct"><img src="https://s1.ax1x.com/2022/07/05/jYWvct.png" alt="jYWvct.png"></a></p></li></ol><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>和查询操作类似，这里就不一一演示了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试Id删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过id批量删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchId</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.deleteBatchIds(Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过map删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老六&quot;</span>);</span><br><span class="line">    userMapper.deleteByMap(map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><blockquote><p>物理删除 ：从数据库中直接移除  </p><p>逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 =&gt; deleted = 1</p></blockquote><p>管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li><p>在数据表中增加一个 deleted 字段</p><p><a href="https://imgtu.com/i/jYWj1I"><img src="https://s1.ax1x.com/2022/07/05/jYWj1I.png" alt="jYWj1I.png"></a></p></li><li><p>实体类中增加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure></li><li><p>配置到组件类里(目前最新版本的已经剔除，默认集成好了，只需添加了注解即可)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑删除组件！</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span>  <span class="comment">#逻辑删除</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><a href="https://imgtu.com/i/jYfpB8"><img src="https://s1.ax1x.com/2022/07/05/jYfpB8.png" alt="jYfpB8.png"></a></p><p>记录依旧在数据库，但是值确已经变化了！</p><p>我们再测试一下查询</p><p><a href="https://imgtu.com/i/jYWxjP"><img src="https://s1.ax1x.com/2022/07/05/jYWxjP.png" alt="jYWxjP.png"></a></p></li></ol><h2 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h2><ul><li>我们在平时的开发中，会遇到一些慢sql。</li><li>测试工具： druid，MybatisPlus提供的性能分析插件</li><li>MybatisPlus提供的性能分析插件的作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间 ，如果超过这个时间就停止运行！</li></ul><p>使用方式：最新版已改为执行SQL分析打印,查阅官网即可：<a href="https://baomidou.com/pages/833fab/">https://baomidou.com/pages/833fab/</a></p><ol><li><p>导入插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SQL执行效率插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="comment">// 设置 dev test 环境开启，保证我们的效率</span></span><br><span class="line"><span class="keyword">public</span> PerformanceInterceptor <span class="title function_">performanceInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PerformanceInterceptor</span> <span class="variable">performanceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">PerformanceInterceptor</span>();</span><br><span class="line">    performanceInterceptor.setMaxTime(<span class="number">100</span>); <span class="comment">// ms设置sql执行的最大时间，如果超过了则不执行</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="literal">true</span>); <span class="comment">// 是否格式化代码</span></span><br><span class="line">    <span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，要在SpringBoot中配置环境为dev或者 test 环境！</p></li><li><p>测试查询全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 参数是一个 Wrapper ，条件构造器，这里我们先不用 null</span></span><br><span class="line">    <span class="comment">// 查询全部用户</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><a href="https://imgtu.com/i/jYfSnf"><img src="https://s1.ax1x.com/2022/07/05/jYfSnf.png" alt="jYfSnf.png"></a></p></li></ol><h2 id="条件构造器：Wrapper"><a href="#条件构造器：Wrapper" class="headerlink" title="条件构造器：Wrapper"></a>条件构造器：Wrapper</h2><p>查阅官方文档使用即可：<a href="https://baomidou.com/pages/10c804/#abstractwrapper">https://baomidou.com/pages/10c804/#abstractwrapper</a></p><p>警告:</p><p>官方不支持以及不赞成在 <strong>RPC</strong> 调用中把 Wrapper 进行传输</p><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC?"></a>什么是RPC?</h3><p><a href="https://blog.csdn.net/lgxzzz/article/details/120921461">https://blog.csdn.net/lgxzzz/article/details/120921461</a></p><p>Wrapper的后期可维护性不高，复杂SQL还是推荐使用xml格式编写</p><h2 id="代码自动生成器"><a href="#代码自动生成器" class="headerlink" title="代码自动生成器"></a>代码自动生成器</h2><p>官方使用的是逆向工程实现：<a href="https://baomidou.com/pages/779a6e/">https://baomidou.com/pages/779a6e/</a></p><p>我推荐使用idea自带插件<strong><a href="https://blog.csdn.net/weixin_43982359/article/details/121799836">EasyCode</a></strong></p><h3 id="我自定义的EasyCode模板"><a href="#我自定义的EasyCode模板" class="headerlink" title="我自定义的EasyCode模板"></a>我自定义的EasyCode模板</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;makejava&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;1.2.4&quot;</span><span class="punctuation">,</span><span class="attr">&quot;userSecure&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currTypeMapperGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Default&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currTemplateGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;GodsTemplate&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currColumnConfigGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Default&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currGlobalConfigGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Default&quot;</span><span class="punctuation">,</span><span class="attr">&quot;typeMapper&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;template&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;GodsTemplate&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;GodsTemplate&quot;</span><span class="punctuation">,</span><span class="attr">&quot;elementList&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;controller.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;Controller\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/controller\&quot;))\n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;controller;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;\nimport org.springframework.web.bind.annotation.*;\nimport io.swagger.annotations.*;\nimport com.baomidou.mybatisplus.plugins.Page;\nimport com.rambler.core.door.Response;\nimport java.util.List;\n \nimport javax.annotation.Resource;\n \n/**\n * @author $!author\n * @since $!time.currTime()\n */\n@Api(tags = \&quot;$!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)控制层\&quot;)\n@RestController\n@RequestMapping(\&quot;/$!tool.firstLowerCase($tableInfo.name)\&quot;)\npublic class $!&#123;tableName&#125; &#123;\n    /**\n     * 服务对象\n     */\n    @Resource\n    private $!&#123;tableInfo.name&#125;Service $!tool.firstLowerCase($tableInfo.name)Service;\n \n    @ApiOperation(value = \&quot;通过主键查询单条数据\&quot;)\n    @ApiImplicitParam(name = \&quot;id\&quot;, value = \&quot;实体id\&quot;, required = true, paramType = \&quot;query\&quot;)\n    @RequestMapping(value = \&quot;selectOne\&quot;, method = RequestMethod.GET)\n    public Response&lt;$tableInfo.name&gt; selectOne($!pk.shortType $!pk.name) &#123;\n        if (id == null) &#123;\n            return Response.createErrorResponse(\&quot;参数错误\&quot;);\n        &#125;\n        $tableInfo.name result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.selectById($!pk.name);\n        if(result != null)&#123;\n            return Response.createSuccessResponse(\&quot;查询成功\&quot;, result);\n        &#125;\n        return Response.createErrorResponse(\&quot;查询失败\&quot;);\n    &#125;\n    \n    @ApiOperation(value = \&quot;发布新增实体类\&quot;)\n    @RequestMapping(value = \&quot;insert\&quot;, method = RequestMethod.POST)\n    public Response&lt;$tableInfo.name&gt; insert(@RequestBody @ApiParam(name = \&quot;文章对象\&quot;, value = \&quot;json格式\&quot;, required = true) $tableInfo.name $!tool.firstLowerCase($tableInfo.name)) &#123;\n        int result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.insert($!tool.firstLowerCase($tableInfo.name));\n        if (result &gt; 0) &#123;\n            return Response.createSuccessResponse(\&quot;新增成功\&quot;, $!tool.firstLowerCase($tableInfo.name));\n        &#125;\n        return Response.createErrorResponse(\&quot;新增失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;更新实体\&quot;)\n    @RequestMapping(value = \&quot;update\&quot;, method = RequestMethod.PUT)\n    public Response&lt;$tableInfo.name&gt; update(@RequestBody @ApiParam(name = \&quot;文章对象\&quot;, value = \&quot;json格式\&quot;, required = true) $tableInfo.name $!tool.firstLowerCase($tableInfo.name)) &#123;\n        int result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.update($!tool.firstLowerCase($tableInfo.name));\n        if (result != -1) &#123;\n            return Response.createSuccessResponse(\&quot;修改成功\&quot;, null);\n        &#125;\n        return Response.createErrorResponse(\&quot;修改失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;通过id删除\&quot;)\n    @ApiImplicitParam(name = \&quot;id\&quot;, value = \&quot;实体id\&quot;, required = true, paramType = \&quot;query\&quot;)\n    @RequestMapping(value = \&quot;delete\&quot;, method = RequestMethod.DELETE)\n    public Response&lt;$tableInfo.name&gt; delete($!pk.shortType $!pk.name) &#123;\n        if (id == null) &#123;\n            return Response.createErrorResponse(\&quot;参数错误\&quot;);\n        &#125;\n        int result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.deleteById($!pk.name);\n        if (result &gt; 0) &#123;\n            return Response.createSuccessResponse(\&quot;删除成功\&quot;, null);\n        &#125;\n        return Response.createErrorResponse(\&quot;删除失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;查询所有\&quot;, notes = \&quot;不需要参数\&quot;)\n    @RequestMapping(value = \&quot;selectAll\&quot;, method = RequestMethod.GET)\n    public Response&lt;List&lt;$tableInfo.name&gt;&gt; selectAll() &#123;\n        List&lt;$tableInfo.name&gt; $!tool.firstLowerCase($tableInfo.name)List = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.selectAll();\n        if ($!tool.firstLowerCase($tableInfo.name)List != null) &#123;\n            return Response.createSuccessResponse(\&quot;查询成功\&quot;, $!tool.firstLowerCase($tableInfo.name)List);\n        &#125;\n        return Response.createErrorResponse(\&quot;查询失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;分页查询\&quot;)\n    @ApiImplicitParams(&#123;\n            @ApiImplicitParam(name = \&quot;start\&quot;, value = \&quot;开始位置,正整数\&quot;, required = true, paramType = \&quot;query\&quot;),\n            @ApiImplicitParam(name = \&quot;limit\&quot;, value = \&quot;页面大小,正整数\&quot;, required = true, paramType = \&quot;query\&quot;)\n    &#125;)\n    @RequestMapping(value = \&quot;selectPage\&quot;, method = RequestMethod.GET)\n    public Response&lt;Page&lt;$tableInfo.name&gt;&gt; selectPage(Integer start, Integer limit) &#123;\n        if(start &lt; 0 || limit &lt;= 0)&#123;\n            return Response.createErrorResponse(\&quot;分页参数错误\&quot;);\n        &#125;\n        List&lt;$tableInfo.name&gt; $!tool.firstLowerCase($tableInfo.name)List = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.selectPage(start, limit);\n        Page&lt;$tableInfo.name&gt; page = new Page&lt;&gt;((start/limit)+1,limit);\n        page.setRecords($!tool.firstLowerCase($tableInfo.name)List);\n        page.setTotal($!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.count());\n        if ($!tool.firstLowerCase($tableInfo.name)List != null) &#123;\n            return Response.createSuccessResponse(\&quot;查询成功\&quot;, page);\n        &#125;\n        return Response.createErrorResponse(\&quot;查询失败\&quot;);\n    &#125;\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;debug.json.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;// 禁止将生成结果写入到文件\n$!callback.setWriteFile(false)\n\n//调试表原始对象\n$!tool.debug($tableInfo.obj)\n\n//调试列原始对象\n$!tool.debug($tableInfo.fullColumn.get(0).obj)\n\n//调试列原始列类型\n$!tool.debug($tableInfo.fullColumn.get(0).obj.dataType)\n\n//获取原始列类型中的字段\nsqlType = $!tool.getField($tableInfo.fullColumn.get(0).obj.dataType, \&quot;typeName\&quot;)\n\n//执行原始列类型中的方法\nsqlTypeLen = $!tableInfo.fullColumn.get(0).obj.dataType.getLength()\n&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;mapper.xml.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##引入mybatis支持\n$!mybatisSupport\n \n##设置保存名称与保存位置\n$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, \&quot;Mapper.xml\&quot;))\n$!callback.setSavePath($tool.append($modulePath, \&quot;/src/main/resources/mybatis/mapper\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC \&quot;-//mybatis.org//DTD Mapper 3.0//EN\&quot; \&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\&quot;&gt;\n&lt;mapper namespace=\&quot;$!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper\&quot;&gt;\n    &lt;!-- 结果集 --&gt;\n    &lt;resultMap type=\&quot;$!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;\&quot; id=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n#foreach($column in $tableInfo.fullColumn)\n        &lt;result property=\&quot;$!column.name\&quot; column=\&quot;$!column.obj.name\&quot; jdbcType=\&quot;$!column.ext.jdbcType\&quot;/&gt;\n#end\n    &lt;/resultMap&gt;\n    \n    &lt;!-- 基本字段 --&gt;\n    &lt;sql id=\&quot;Base_Column_List\&quot;&gt;\n        #allSqlColumn()\n    &lt;/sql&gt;\n    \n    &lt;!-- 查询单个 --&gt;\n    &lt;select id=\&quot;selectById\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n          &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n        where $!pk.obj.name = #&#123;$!pk.name&#125;\n    &lt;/select&gt;\n \n    &lt;!-- 分页查询 --&gt;\n    &lt;select id=\&quot;selectPage\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n        &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n        limit #&#123;start&#125;,#&#123;limit&#125;\n    &lt;/select&gt;\n \n    &lt;!-- 查询全部 --&gt;\n    &lt;select id=\&quot;selectAll\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n        &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n    &lt;/select&gt;\n \n    &lt;!--通过实体作为筛选条件查询--&gt;\n    &lt;select id=\&quot;selectList\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n        &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n        &lt;where&gt;\n        #foreach($column in $tableInfo.fullColumn)\n            &lt;if test=\&quot;$!column.name != null#if($column.type.equals(\&quot;java.lang.String\&quot;)) and $!column.name != &#x27;&#x27;#end\&quot;&gt;\n                and $!column.obj.name = #&#123;$!column.name&#125;\n            &lt;/if&gt;\n        #end\n        &lt;/where&gt;\n    &lt;/select&gt;\n \n    &lt;!-- 新增所有列 --&gt;\n    &lt;insert id=\&quot;insert\&quot; keyProperty=\&quot;$!pk.name\&quot; useGeneratedKeys=\&quot;true\&quot;&gt;\n        insert into $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.fullColumn)$!column.obj.name#if($velocityHasNext), #end#end)\n        values ( #foreach($column in $tableInfo.fullColumn)#&#123;$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end#end)\n    &lt;/insert&gt;\n    \n    &lt;!-- 批量新增 --&gt;\n    &lt;insert id=\&quot;batchInsert\&quot;&gt;\n        insert into $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.fullColumn)$!column.obj.name#if($velocityHasNext), #end#end)\n        values \n        &lt;foreach collection=\&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)s\&quot; item=\&quot;item\&quot; index=\&quot;index\&quot; separator=\&quot;,\&quot;&gt;\n        (\n            #foreach($column in $tableInfo.fullColumn)\n            #&#123;item.$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end\n#end\n         )\n         &lt;/foreach&gt;\n    &lt;/insert&gt;\n \n    &lt;!-- 通过主键修改数据 --&gt;\n    &lt;update id=\&quot;update\&quot;&gt;\n        update $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125;\n        &lt;set&gt;\n        #foreach($column in $tableInfo.otherColumn)\n            &lt;if test=\&quot;$!column.name != null#if($column.type.equals(\&quot;java.lang.String\&quot;)) and $!column.name != &#x27;&#x27;#end\&quot;&gt;\n                $!column.obj.name = #&#123;$!column.name&#125;,\n            &lt;/if&gt;\n        #end\n        &lt;/set&gt;\n        where $!pk.obj.name = #&#123;$!pk.name&#125;\n    &lt;/update&gt;\n \n    &lt;!--通过主键删除--&gt;\n    &lt;delete id=\&quot;deleteById\&quot;&gt;\n        delete from $!&#123;tableInfo.obj.name&#125; where $!pk.obj.name = #&#123;$!pk.name&#125;\n    &lt;/delete&gt;\n    \n    &lt;!-- 总数 --&gt;\n    &lt;select id=\&quot;count\&quot; resultType=\&quot;int\&quot;&gt;\n        select count(*) from $!&#123;tableInfo.obj.name&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;service.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;Service\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/service\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport java.util.List;\nimport java.util.Map;\n \n/**\n * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务接口\n *\n * @author $!author\n * @since $!time.currTime()\n */\npublic interface $!&#123;tableName&#125; &#123;\n \n    /**\n     * 通过ID查询单条数据\n     */\n    $!&#123;tableInfo.name&#125; selectById($!pk.shortType $!pk.name);\n \n    /**\n     * 分页查询\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectPage(int start, int limit);\n \n    /**\n     * 查询全部\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectAll();\n    \n    /**\n     * 通过实体作为筛选条件查询\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectList($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 新增数据\n     */\n    int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n\t\n\t/**\n     * 批量新增\n     */\n    int batchInsert(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)s);\n\t\n    /**\n     * 修改数据\n     */\n    int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 通过主键删除数据\n     */\n    int deleteById($!pk.shortType $!pk.name);\n    \n    /**\n     * 查询总数据数\n     */\n    int count();\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;serviceImpl.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;ServiceImpl\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/service/impl\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service.impl;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;\nimport $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;\nimport org.springframework.stereotype.Service;\n \nimport javax.annotation.Resource;\nimport java.util.List;\n \n/**\n * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务实现类\n *\n * @author $!author\n * @since $!time.currTime()\n */\n@Service(\&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Service\&quot;)\npublic class $!&#123;tableName&#125; implements $!&#123;tableInfo.name&#125;Service &#123;\n    @Resource\n    private $!&#123;tableInfo.name&#125;Mapper $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Mapper;\n \n    /**\n     * 通过ID查询单条数据\n     *\n     * @param $!pk.name 主键\n     * @return 实例对象\n     */\n    @Override\n    public $!&#123;tableInfo.name&#125; selectById($!pk.shortType $!pk.name) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectById($!pk.name);\n    &#125;\n \n    /**\n     * 分页查询\n     *\n     * @param start 查询起始位置\n     * @param limit 查询条数\n     * @return 对象列表\n     */\n    @Override\n    public List&lt;$!&#123;tableInfo.name&#125;&gt; selectPage(int start, int limit) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectPage(start, limit);\n    &#125;\n    \n    /**\n     * 查询全部\n     *\n     * @return 对象列表\n     */\n    @Override\n    public List&lt;$!&#123;tableInfo.name&#125;&gt; selectAll() &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectAll();\n    &#125;\n \n    /**\n     * 根据实体类进行筛选\n     \n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 对象列表\n     */\n    @Override\n    public List&lt;$!&#123;tableInfo.name&#125;&gt; selectList($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectList($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n    &#125;\n    \n    /**\n     * 新增数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 生效条数\n     */\n    @Override\n    public int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.insert($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n    &#125;\n    \n    /**\n     * 批量新增\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List 实例对象\n     * @return 生效条数\n     */\n    @Override\n    public int batchInsert(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.batchInsert($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List);\n    &#125;\n    \n \n    /**\n     * 修改数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 实例对象\n     */\n    @Override\n    public int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.update($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n    &#125;\n \n    /**\n     * 通过主键删除数据\n     *\n     * @param $!pk.name 主键\n     * @return 是否成功\n     */\n    @Override\n    public int deleteById($!pk.shortType $!pk.name) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.deleteById($!pk.name);\n    &#125;\n    \n    /**\n     * 查询总数据数\n     *\n     * @return 数据总数\n     */\n    @Override\n    public int count() &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.count();\n    &#125;\n    \n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;mapper.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;Mapper\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/mapper\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;mapper;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport org.apache.ibatis.annotations.Param;\nimport java.util.List;\nimport java.util.Map;\n \n/**\n * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表数据库访问层\n *\n * @author $!author\n * @since $!time.currTime()\n */\npublic interface $!&#123;tableName&#125; &#123;\n \n    /**\n     * 通过ID查询单条数据\n     *\n     * @param $!pk.name 主键\n     * @return 实例对象\n     */\n    $!&#123;tableInfo.name&#125; selectById($!pk.shortType $!pk.name);\n\t\n    /**\n     * 分页查询\n     *\n     * @param start 查询起始位置\n     * @param limit 查询条数\n     * @return 对象列表\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectPage(@Param(\&quot;start\&quot;) int start, @Param(\&quot;limit\&quot;) int limit);\n \n    /**\n     * 查询全部\n     *\n     * @return 对象列表\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectAll();\n    \n    /**\n     * 通过实体作为筛选条件查询\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 对象列表\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectList($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 新增数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 影响行数\n     */\n    int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n\t\n\t/**\n     * 批量新增\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List 实例对象的集合\n     * @return 影响行数\n     */\n     int batchInsert(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List);\n\t\n    /**\n     * 修改数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 影响行数\n     */\n    int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 通过主键删除数据\n     *\n     * @param $!pk.name 主键\n     * @return 影响行数\n     */\n    int deleteById($!pk.shortType $!pk.name);\n \n    /**\n     * 查询总数据数\n     *\n     * @return 数据总数\n     */\n    int count();\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;pojo.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##引入宏定义\n$!define\n \n##使用宏定义设置回调(保存位置与文件后缀)\n#save(\&quot;/pojo\&quot;, \&quot;.java\&quot;)\n \n##使用宏定义设置包后缀\n#setPackageSuffix(\&quot;pojo\&quot;)\n \n##使用全局变量实现默认包导入\n$!autoImport\nimport java.io.Serializable;\n \n##使用宏定义实现类注释信息\n#tableComment(\&quot;实体类\&quot;)\npublic class $!&#123;tableInfo.name&#125; implements Serializable &#123;\n    private static final long serialVersionUID = $!tool.serial();\n#foreach($column in $tableInfo.fullColumn)\n    #if($&#123;column.comment&#125;)/**\n    * $&#123;column.comment&#125;\n    */#end\n \n    private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;\n#end\n \n#foreach($column in $tableInfo.fullColumn)\n    ##使用宏定义实现get,set方法\n    #getSetMethod($column)\n#end\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;columnConfig&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;globalConfig&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MybatisPlus </category>
          
          <category> 面试加分项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> MybatisPlus </tag>
            
            <tag> 面试加分项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux快速入门</title>
      <link href="/post/502a6bfe.html"/>
      <url>/post/502a6bfe.html</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>本教程是根据B站Up主狂神说记得笔记，有需要查看视频的小伙伴可以去看看狂神的视频，真的非常好！</p><p>狂神说Linux视频地址：<a href="https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p><hr><h1 id="服务器相关知识"><a href="#服务器相关知识" class="headerlink" title="服务器相关知识"></a>服务器相关知识</h1><h2 id="为什么程序员都需要一个自己的服务器？"><a href="#为什么程序员都需要一个自己的服务器？" class="headerlink" title="为什么程序员都需要一个自己的服务器？"></a>为什么程序员都需要一个自己的服务器？</h2><ol><li>作为一个程序员，必须要学会发布自己的网站和项目!</li><li>练习Linux操作</li><li>把自己的远程仓库、远程数据库、远程tomcat等搭建在服务器上</li><li>练习Linux进行任意的环境部署操作! 大部人都是Window下开发，不熟悉Linux</li></ol><h2 id="如何购买服务器？"><a href="#如何购买服务器？" class="headerlink" title="如何购买服务器？"></a>如何购买服务器？</h2><p>新手可以先去阿里云领一个免费的服务器先用着</p><p>阿里云新人服务器领取地址：<br><a href="https://imgtu.com/i/jFDbm6"><img src="https://s1.ax1x.com/2022/06/25/jFDbm6.jpg" alt="jFDbm6.jpg"></a><br>学生的话后期可以购买学生机，阿里云只有未满24周岁都可以享受学生机优惠</p><p>优惠地址：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p><p>购买服务器时系统选择CentOS 推荐版本7.X，因为8.0之后改了好多命令，云盘的话选择40G就够用了，如下图所示：<br><a href="https://imgtu.com/i/jFDzpd"><img src="https://s1.ax1x.com/2022/06/25/jFDzpd.jpg" alt="jFDzpd.jpg"></a></p><h2 id="买完服务器之后该干什么？"><a href="#买完服务器之后该干什么？" class="headerlink" title="买完服务器之后该干什么？"></a>买完服务器之后该干什么？</h2><p>首先服务器就是一个远程的Linux</p><ol><li>在阿里云购买服务器需要开通安全组设置去进行端口的映射，比如8080或者3306<br><a href="https://imgtu.com/i/jFcwxH"><img src="https://s1.ax1x.com/2022/06/25/jFcwxH.jpg" alt="jFcwxH.jpg"></a></li><li>获取服务器的公网ip地址，修改实例名称和密码，记住第一次修改需要重启，修改后就可以使用Xshell进行远程连接了</li></ol><p><a href="https://imgtu.com/i/jmFkJe"><img src="https://s1.ax1x.com/2022/06/28/jmFkJe.jpg" alt="jmFkJe.jpg"></a></p><h2 id="连接到服务器之后，我们就需要搭建环境了"><a href="#连接到服务器之后，我们就需要搭建环境了" class="headerlink" title="连接到服务器之后，我们就需要搭建环境了"></a>连接到服务器之后，我们就需要搭建环境了</h2><p>搭建环境有两种方式：</p><p>1、傻瓜式(使用宝塔面板)</p><p>安装网站：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>切记安装前记得先在安全组中开发如下端口：</p><p><a href="https://imgtu.com/i/jmFPIO"><img src="https://s1.ax1x.com/2022/06/28/jmFPIO.jpg" alt="jmFPIO.jpg"></a></p><p>安装命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</span><br></pre></td></tr></table></figure><p>下载完毕之后，就可以得到一个地址：宝塔的管理面板</p><ul><li>url：</li><li>username：</li><li>password：</li></ul><p><a href="https://imgtu.com/i/jmF9Z6"><img src="https://s1.ax1x.com/2022/06/28/jmF9Z6.jpg" alt="jmF9Z6.jpg"></a></p><p><a href="https://imgtu.com/i/jmFCdK"><img src="https://s1.ax1x.com/2022/06/28/jmFCdK.jpg" alt="jmFCdK.jpg"></a></p><h2 id="自定义安装服务器环境"><a href="#自定义安装服务器环境" class="headerlink" title="自定义安装服务器环境"></a>自定义安装服务器环境</h2><p><a href="https://imgtu.com/i/jmFARH"><img src="https://s1.ax1x.com/2022/06/28/jmFARH.jpg" alt="jmFARH.jpg"></a></p><blockquote><p>一键部署应用</p></blockquote><p><a href="https://imgtu.com/i/jmFEzd"><img src="https://s1.ax1x.com/2022/06/28/jmFEzd.jpg" alt="jmFEzd.jpg"></a></p><blockquote><p>端口开启</p></blockquote><p><a href="https://imgtu.com/i/jmFZQA"><img src="https://s1.ax1x.com/2022/06/28/jmFZQA.jpg" alt="jmFZQA.jpg"></a></p><blockquote><p>放入网站进行访问</p></blockquote><p>比如TomCat就直接放到webapps目录下</p><p>特殊的网站：开源项目，就安装自己的操作来</p><p>注意：上传文件尽量使用XFTP</p><blockquote><p>SpringBoot项目怎么部署？</p></blockquote><p>打成war包或者jar包</p><ul><li>war包直接丢到Tomcat即可</li><li>jar包直接用java-jar执行即可访问</li></ul><p>注意：网站如果访问失败，一定是防火墙问题，这个时候去检查Linux服务器和阿里云安全组面板</p><p>2、命令式(原生)</p><h1 id="Linux入门概述"><a href="#Linux入门概述" class="headerlink" title="Linux入门概述"></a>Linux入门概述</h1><h2 id="我们为什么要学习Linux"><a href="#我们为什么要学习Linux" class="headerlink" title="我们为什么要学习Linux?"></a>我们为什么要学习Linux?</h2><blockquote><p>linux诞生了这么多年，以前还喊着如何能取代windows系统，现在这个口号已经小多了，任何事物发展都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即使他们自己不用亲戚朋友还是要用，没有办法的事情。</p><p>用习惯了windows操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着linux就没有用武之地了。在服务器端，在开发领域linux倒是越来越受欢迎，很多程序员都觉得不懂点linux都觉得不好意思，linux在开源社区的地位依然岿然不动。</p><p>尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！</p></blockquote><h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><blockquote><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p></blockquote><h2 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h2><blockquote><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包</p></blockquote><p>Kali linux：做安全渗透测试使用的</p><p><a href="https://imgtu.com/i/juu9oj"><img src="https://s1.ax1x.com/2022/06/30/juu9oj.png" alt="juu9oj.png"></a></p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><p><a href="https://imgtu.com/i/juupwQ"><img src="https://s1.ax1x.com/2022/06/30/juupwQ.png" alt="juupwQ.png"></a></p><p>有条件使用Redhat的人可以考虑考一个红帽子工程师，可以让你在面试的时候更突出一点</p><blockquote><p>Linux应用领域</p></blockquote><p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p><p>目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p><ul><li>巴西联邦政府由于支持 Linux 而世界闻名。</li><li>有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</li><li>印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</li><li>中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</li><li>在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</li><li>葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。</li><li>法国和德国同样开始逐步采用 Linux。</li></ul><blockquote><p>Linux vs Windows</p></blockquote><p><a href="https://imgtu.com/i/juuPFs"><img src="https://s1.ax1x.com/2022/06/30/juuPFs.png" alt="juuPFs.png"></a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也可以直接买一台学习用用！</p><blockquote><p>安装CentOS（虚拟机安装，耗资源）</p></blockquote><p>这里推荐使用VMware Workstation 对新手会比较友好一点，安装完后需要激活码，这里就不教破解方法了，自行百度即可</p><p>VMware Workstation官网：<a href="https://www.vmware.com/cn/products/workstation-pro.html">https://www.vmware.com/cn/products/workstation-pro.html</a></p><p>下载激活好后进行如下操作：</p><p>可以通过镜像进行安装！官方网址：<a href="https://www.centos.org/download/">https://www.centos.org/download/</a></p><p><a href="https://blog.csdn.net/SDAU_LGX/article/details/120669344?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165647175016782246484602%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165647175016782246484602&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-120669344-null-null.142^v25^pc_rank_34,157^v15^new_3&amp;utm_term=centos7%E9%95%9C%E5%83%8F&amp;spm=1018.2226.3001.4187">安装教程</a></p><blockquote><p>购买云服务器（推荐）</p></blockquote><p>云服务器就是一个远程电脑，服务器一般不会关机</p><p>虚拟机安装后占用空间，也会有些卡顿，我们作为程序员其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作；</p><p>1、阿里云购买服务器：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p><p>2、购买完毕后，获取服务器的ip地址，重置服务器密码，就可以远程登录了</p><p>3、下载 xShell（远程连接使用）和Xftp 工具（文件上传使用）</p><p>这里我给大家提供了我的免费下载地址：</p><p>链接：<a href="https://pan.baidu.com/s/19yBxIyCP69tHzm8Y2NogNw">https://pan.baidu.com/s/19yBxIyCP69tHzm8Y2NogNw</a><br>提取码：p73z </p><p>连接成功效果如下：</p><p><a href="https://imgtu.com/i/juuSeg"><img src="https://s1.ax1x.com/2022/06/30/juuSeg.png" alt="juuSeg.png"></a></p><p>这里就是我们的Linux操作系统了!以后的操作都在这里操作，项目也在这里进行发布!</p><p><strong>注意事项：</strong></p><p>如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！</p><h1 id="走近Linux系统"><a href="#走近Linux系统" class="headerlink" title="走近Linux系统"></a>走近Linux系统</h1><blockquote><p>开机登录</p></blockquote><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”<strong>守护进程</strong>“（daemon）。</p><p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><blockquote><p>关机</p></blockquote><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>关机指令为：shutdown ；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sync</span> <span class="comment"># 将数据由内存同步到硬盘中。</span></span><br><span class="line"></span><br><span class="line">shutdown <span class="comment"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span></span><br><span class="line"></span><br><span class="line">shutdown –h 10 <span class="comment"># 这个命令告诉大家，计算机将在10分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h now <span class="comment"># 立马关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 <span class="comment"># 系统会在今天20:25关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h +10 <span class="comment"># 十分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –r now <span class="comment"># 系统立马重启</span></span><br><span class="line"></span><br><span class="line">shutdown –r +10 <span class="comment"># 系统十分钟后重启</span></span><br><span class="line"></span><br><span class="line">reboot <span class="comment"># 就是重启，等同于 shutdown –r now</span></span><br><span class="line"></span><br><span class="line">halt <span class="comment"># 关闭系统，等同于shutdown –h now 和 poweroff</span></span><br></pre></td></tr></table></figure><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><blockquote><p>系统目录结构</p></blockquote><p>1、在Linux中一切皆文件<br>2、根目录/，所有的文件都挂载在这个节点下</p><p>登录系统后，在当前命令窗口下输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /</span><br></pre></td></tr></table></figure><p>你会看到如下图所示：</p><p><a href="https://imgtu.com/i/junxOS"><img src="https://s1.ax1x.com/2022/06/30/junxOS.png" alt="junxOS.png"></a></p><p>树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下）</p><p><a href="https://imgtu.com/i/juuiYn"><img src="https://s1.ax1x.com/2022/06/30/juuiYn.png" alt="juuiYn.png"></a></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。（切记不要动他）</li><li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。（<strong>重点</strong>）</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。（<strong>重点</strong>）</li><li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。（切记不要动他）</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放突然关机的一些文件）</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。（我们后面会把一些本地文件挂载在这个目录下）</li><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。(<strong>非常重要</strong>)</li><li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。（不用管）</li><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。（<strong>重点</strong>）</li><li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，比如安装包。（<strong>常用</strong>）</li><li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。（<strong>重点</strong>）</li><li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li><li><strong>/www:</strong>存放服务器网站相关的资源，环境，网站的项目，这个是只有服务器才有的（<strong>重点</strong>）</li></ul><p><a href="https://imgtu.com/i/juuFWq"><img src="https://s1.ax1x.com/2022/06/30/juuFWq.png" alt="juuFWq.png"></a></p><h1 id="常用的基本命令（重点）"><a href="#常用的基本命令（重点）" class="headerlink" title="常用的基本命令（重点）"></a>常用的基本命令（重点）</h1><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！</p><ul><li>cd :切换目录命令!</li><li>./ :当前目录</li><li>cd .. :返回上一级目录</li></ul><h3 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h3><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h4 id="ls-（列出目录）"><a href="#ls-（列出目录）" class="headerlink" title="ls （列出目录）"></a>ls （列出目录）</h4><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls [-aAdfFhilnrRSt] 目录名称</span></span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>注意：所有的Linux命令都可以进行组合使用!</p><p>比如：将目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls -al ~</span></span><br></pre></td></tr></table></figure><h4 id="cd-（切换目录）"><a href="#cd-（切换目录）" class="headerlink" title="cd （切换目录）"></a>cd （切换目录）</h4><p>cd+目录名（绝对路径都是以/开头，相对路径，对于当前目录该如何寻找../ ../）</p><p><a href="https://imgtu.com/i/juuAS0"><img src="https://s1.ax1x.com/2022/06/30/juuAS0.png" alt="juuAS0.png"></a></p><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [相对路径或绝对路径]</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到用户目录下</span></span><br><span class="line">[root@apathy /]<span class="comment"># cd home  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mkdir 命令创建 apathystudy 目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir apathystudy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 kuangstudy 目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># cd apathystudy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到上一级</span></span><br><span class="line">[root@apathy apathystudy]<span class="comment"># cd ..</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到根目录</span></span><br><span class="line">[root@apathy apathystudy]<span class="comment"># cd /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line">[root@apathy apathystudy]<span class="comment"># cd ~</span></span><br></pre></td></tr></table></figure><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><h4 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd ( 显示目前所在的目录 )"></a>pwd ( 显示目前所在的目录 )</h4><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy apathystudy]<span class="comment">#pwd [-P]</span></span><br></pre></td></tr></table></figure><p>选项与参数：<strong>-P</strong> ：显示出确实的路径，而非使用连接(link) 路径。</p><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单纯显示出目前的工作目录</span></span><br><span class="line">[root@apathy ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是链接，要显示真实地址，可以使用 -P参数</span></span><br><span class="line">[root@apathy /]<span class="comment"># cd bin</span></span><br><span class="line">[root@apathy bin]<span class="comment"># pwd -P</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure><h4 id="mkdir-（创建新目录）"><a href="#mkdir-（创建新目录）" class="headerlink" title="mkdir （创建新目录）"></a>mkdir （创建新目录）</h4><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [-mp] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入我们用户目录下</span></span><br><span class="line">[root@apathy /]<span class="comment"># cd /home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 test 文件夹</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多层级目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir test1/test2/test3/test4</span></span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘test1/test2/test3/test4’:</span><br><span class="line">No such file or directory  <span class="comment"># &lt;== 没办法直接创建此目录啊！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir -p test1/test2/test3/test4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建权限为 rwx--x--x 的目录。</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir -m 711 test2</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls -l</span></span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 <span class="built_in">test</span></span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br></pre></td></tr></table></figure><h4 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir ( 删除空的目录 )"></a>rmdir ( 删除空的目录 )</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> [-p] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：<strong>-p ：</strong>连同上一级『空的』目录也一起删除</p><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看看有多少目录存在？</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls -l</span></span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 <span class="built_in">test</span></span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可直接删除掉，没问题</span></span><br><span class="line">[root@apathy home]<span class="comment"># rmdir test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为尚有内容，所以无法删除！</span></span><br><span class="line">[root@apathy home]<span class="comment"># rmdir test1</span></span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove ‘test1’: Directory not empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span></span><br><span class="line">[root@apathy home]<span class="comment"># rmdir -p test1/test2/test3/test4</span></span><br></pre></td></tr></table></figure><p>注意：rmdir仅能删除空的目录，如果下面存在文件，需要先删除文件，也可以使用递归删除多个目录-p参数即可</p><h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp ( 复制文件或目录 )"></a>cp ( 复制文件或目录 )</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># cp [-adfilprsu] 来源档(source) 目标档(destination)</span></span><br><span class="line">[root@www ~]<span class="comment"># cp [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当于 -pdr 的意思，至于 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用于目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找一个有文件的目录，我这里找到 root目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># cd /root</span></span><br><span class="line">[root@apathy ~]<span class="comment"># ls</span></span><br><span class="line">install.sh</span><br><span class="line">[root@apathy ~]<span class="comment"># cd /home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 root目录下的install.sh 到 home目录下</span></span><br><span class="line">[root@apathy home]<span class="comment"># cp /root/install.sh /home</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次复制，加上-i参数，增加覆盖询问？</span></span><br><span class="line">[root@apathy home]<span class="comment"># cp -i /root/install.sh /home</span></span><br><span class="line"><span class="built_in">cp</span>: overwrite ‘/home/install.sh’? y <span class="comment"># n不覆盖，y为覆盖</span></span><br></pre></td></tr></table></figure><h4 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm ( 移除文件或目录 )"></a>rm ( 移除文件或目录 )</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> [-fir] 文件或目录</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息，相当于强制删除；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /<span class="comment">#系统中所有的文件就被删除了，删库跑路就是这么操作的!</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span></span><br><span class="line">[root@apathy home]<span class="comment"># rm -i install.sh</span></span><br><span class="line"><span class="built_in">rm</span>: remove regular file ‘install.sh’? y</span><br><span class="line"><span class="comment"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尽量不要在服务器上使用 rm -rf /</span></span><br></pre></td></tr></table></figure><h4 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv  ( 移动文件与目录，或修改名称 )"></a>mv  ( 移动文件与目录，或修改名称 )</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># mv [-fiu] source destination</span></span><br><span class="line">[root@www ~]<span class="comment"># mv [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制一个文件到当前目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># cp /root/install.sh /home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个文件夹 test</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将复制过来的文件移动到我们创建的目录，并查看</span></span><br><span class="line">[root@apathy home]<span class="comment"># mv install.sh test</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">[root@apathy home]<span class="comment"># cd test</span></span><br><span class="line">[root@apathy <span class="built_in">test</span>]<span class="comment"># ls</span></span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件夹重命名，然后再次查看！</span></span><br><span class="line">[root@apathy <span class="built_in">test</span>]<span class="comment"># cd ..</span></span><br><span class="line">[root@apathy home]<span class="comment"># mv test mvtest</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line">mvtest</span><br></pre></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><h4 id="看懂文件属性"><a href="#看懂文件属性" class="headerlink" title="看懂文件属性"></a>看懂文件属性</h4><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p><p><a href="https://imgtu.com/i/jGNug1"><img src="https://s1.ax1x.com/2022/07/04/jGNug1.png" alt="jGNug1.png"></a></p><p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li>当为[ <strong>d</strong> ]则是目录；（<strong>常用</strong>）</li><li>当为[ <strong>-</strong> ]则是文件；（<strong>常用</strong>）</li><li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；（<strong>常用</strong>）</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p><p><a href="https://imgtu.com/i/jGNQu6"><img src="https://s1.ax1x.com/2022/07/04/jGNQu6.png" alt="jGNQu6.png"></a></p><p>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中：</p><p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p><p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p><h4 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h4><p><strong>1、chgrp：更改文件属组</strong>（尽量不要修改）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [-R] 属组名 文件名</span><br></pre></td></tr></table></figure><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong>（尽量不要修改）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> [–R] 属主名 文件名</span><br><span class="line"><span class="built_in">chown</span> [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure><p><strong>3、chmod：更改文件9个属性</strong>（常用，必须掌握）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><p>Linux文件属性有两种设置方法，一种是数字（常用的），一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br><span class="line"></span><br><span class="line">可读可写不可执行   rw-   6</span><br><span class="line"></span><br><span class="line">可读可写可执行     rwx   7</span><br><span class="line"></span><br><span class="line">chomd 777文件赋予所有用户可读可写可执行</span><br></pre></td></tr></table></figure><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—-] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= —- = 0+0+0 = 0</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 770 filename</span><br></pre></td></tr></table></figure><p>可以自己下去多进行测试！</p><h2 id="文件内容查看（必须掌握）"><a href="#文件内容查看（必须掌握）" class="headerlink" title="文件内容查看（必须掌握）"></a>文件内容查看（必须掌握）</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li></ul><p><a href="https://imgtu.com/i/jGNn3R"><img src="https://s1.ax1x.com/2022/07/04/jGNn3R.png" alt="jGNn3R.png"></a></p><ul><li>nl  显示的时候，顺道输出行号！  看代码的时候，希望显示行号!（常用）</li></ul><p><a href="https://imgtu.com/i/jGNZ4J"><img src="https://s1.ax1x.com/2022/07/04/jGNZ4J.png" alt="jGNZ4J.png"></a></p><ul><li>more 一页一页的显示文件内容，带余下内容的（空格代表翻页，enter代表向下看一行，:f行号)</li></ul><p><a href="https://imgtu.com/i/jGNKjx"><img src="https://s1.ax1x.com/2022/07/04/jGNKjx.png" alt="jGNKjx.png"></a></p><ul><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！(空格下翻页，上下键代表翻动页面!退出命令为：q，查找字符串：/要查询的字符向下查询，向上查询使用?要查询的字符串，n继续搜寻下一个，向上寻找使用N）</li><li>head 只看头几行  通过-n参数来控制显示几行!</li><li><a href="https://imgtu.com/i/jGNlDK"><img src="https://s1.ax1x.com/2022/07/04/jGNlDK.png" alt="jGNlDK.png"></a></li><li>tail 只看尾巴几行  通过-n参数来控制显示几行!</li></ul><p>你可以使用 <em>man [命令]</em>来查看各个命令的使用文档，如 ：man cp。</p><p>网络配置目录:cd /etc/sysconfig/network-scripts     系统版本必须是CentOS7</p><p><a href="https://imgtu.com/i/jGNmC9"><img src="https://s1.ax1x.com/2022/07/04/jGNmC9.png" alt="jGNmC9.png"></a></p><p>ifconfig命令查看网络配置!</p><h4 id="cat-由第一行开始显示文件内容"><a href="#cat-由第一行开始显示文件内容" class="headerlink" title="cat 由第一行开始显示文件内容"></a>cat 由第一行开始显示文件内容</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [-AbEnTv]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span></span><br><span class="line">[root@apathy ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h4 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h4><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy ~]<span class="comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure><h4 id="nl-显示行号"><a href="#nl-显示行号" class="headerlink" title="nl  显示行号"></a>nl  显示行号</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span> [-bnw] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy ~]<span class="comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">1DEVICE=eth0</span><br><span class="line">2BOOTPROTO=dhcp</span><br><span class="line">3ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h4 id="more-一页一页翻动"><a href="#more-一页一页翻动" class="headerlink" title="more  一页一页翻动"></a>more  一页一页翻动</h4><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter   ：代表向下翻『一行』；</li><li>/字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f    ：立刻显示出档名以及目前显示的行数；</li><li>q    ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%) <span class="comment"># 重点在这一行喔！你的光标也会在这里等待你的命令</span></span><br></pre></td></tr></table></figure><h4 id="less-一页一页翻动，以下实例输出-etc-man-config文件的内容："><a href="#less-一页一页翻动，以下实例输出-etc-man-config文件的内容：" class="headerlink" title="less  一页一页翻动，以下实例输出/etc/man.config文件的内容："></a>less  一页一页翻动，以下实例输出/etc/man.config文件的内容：</h4><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串  ：向下搜寻『字串』的功能；</li><li>?字串  ：向上搜寻『字串』的功能；</li><li>n   ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N   ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q   ：离开 less 这个程序；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">:   <span class="comment"># 这里可以等待你输入命令！</span></span><br></pre></td></tr></table></figure><h4 id="head-取出文件前面几行"><a href="#head-取出文件前面几行" class="headerlink" title="head  取出文件前面几行"></a>head  取出文件前面几行</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：<strong>-n</strong> 后面接数字，代表显示几行的意思！</p><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># head -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure><h4 id="tail-取出文件后面几行"><a href="#tail-取出文件后面几行" class="headerlink" title="tail  取出文件后面几行"></a>tail  取出文件后面几行</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># tail -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure><h4 id="拓展：Linux-链接概念"><a href="#拓展：Linux-链接概念" class="headerlink" title="拓展：Linux 链接概念"></a>拓展：Linux 链接概念</h4><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><p>Linux的链接分为两种∶硬链接、软链接!</p><p><strong>硬链接∶</strong>A—B，假设B是A的硬链接，那么他们两个指向了同一个文件!允许一个文件拥有多个路径，用户可以通过这种<br>硬链接到一些重要文件上，防止误删!<br><strong>软链接︰</strong>类似Window下的快捷方式，删除的源文件，快捷方式也访问不了!</p><p>创建连接In命令!</p><p>touch命令创建文件!</p><p>echo输入字符串,也可以输入到文件中!</p><p><strong>硬连接</strong></p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><strong>软连接</strong></p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><p><strong>测试：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy /]<span class="comment"># cd /home</span></span><br><span class="line">[root@apathy home]<span class="comment"># touch f1 # 创建一个测试文件f1</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line">f1</span><br><span class="line">[root@apathy home]<span class="comment"># ln f1 f2     # 创建f1的一个硬连接文件f2</span></span><br><span class="line">[root@apathy home]<span class="comment"># ln -s f1 f3   # 创建f1的一个符号连接文件f3</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls -li       # -i参数显示文件的inode节点信息</span></span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure><p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span></span><br><span class="line">[root@apathy home]<span class="comment"># echo &quot;I am f1 file&quot; &gt;&gt;f1</span></span><br><span class="line">[root@apathy home]<span class="comment"># cat f1</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># cat f3</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># rm -f f1</span></span><br><span class="line">[root@apathy home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># cat f3</span></span><br><span class="line"><span class="built_in">cat</span>: f3: No such file or directory</span><br></pre></td></tr></table></figure><p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><ul><li>删除符号连接f3,对f1,f2无影响；</li><li>删除硬连接f2，对f1,f3也无影响；</li><li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li><li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li></ul><h2 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h2><h3 id="什么是Vim编辑器"><a href="#什么是Vim编辑器" class="headerlink" title="什么是Vim编辑器"></a>什么是Vim编辑器</h3><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。尤其是Linux中，必须要会使用Vim（<strong>查看内容，编辑内容，保存内容</strong>!)</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p><p>vim 则可以说是程序开发者的一项很好用的工具。</p><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><p>vim 键盘图：</p><p><a href="https://imgtu.com/i/jGN22n"><img src="https://s1.ax1x.com/2022/07/04/jGN22n.png" alt="jGN22n.png"></a></p><h3 id="三种使用模式"><a href="#三种使用模式" class="headerlink" title="三种使用模式"></a>三种使用模式</h3><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p><p><strong>命令模式：</strong></p><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p><a href="https://imgtu.com/i/jGNrVS"><img src="https://s1.ax1x.com/2022/07/04/jGNrVS.png" alt="jGNrVS.png"></a></p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。如果是编辑模式，需要先退出编辑模式!按ESC</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><p><strong>输入模式：</strong></p><p>在命令模式下按下i就进入了输入模式：</p><p><a href="https://imgtu.com/i/jGNsUg"><img src="https://s1.ax1x.com/2022/07/04/jGNsUg.png" alt="jGNsUg.png"></a></p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><p><strong>底线命令模式</strong></p><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。光标就移动到了最底下，就可以在这里输入一些底线命令了!</p><p><a href="https://imgtu.com/i/jGN0Df"><img src="https://s1.ax1x.com/2022/07/04/jGN0Df.png" alt="jGN0Df.png"></a></p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p><a href="https://imgtu.com/i/jGNBb8"><img src="https://s1.ax1x.com/2022/07/04/jGNBb8.png" alt="jGNBb8.png"></a></p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><p><a href="https://imgtu.com/i/jGNg8s"><img src="https://s1.ax1x.com/2022/07/04/jGNg8s.png" alt="jGNg8s.png"></a></p><h3 id="完整演示说明"><a href="#完整演示说明" class="headerlink" title="完整演示说明"></a>完整演示说明</h3><p>新建或者编辑文件，按i进入编辑模式，编写内容，编写完成后退出编辑模式，esc，退出之后进入底线命令模式︰ wq<br>保存退出!</p><p>如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy home]<span class="comment"># vim apathystudy.txt</span></span><br></pre></td></tr></table></figure><p>然后就会进入文件</p><p><a href="https://imgtu.com/i/jGNy5Q"><img src="https://s1.ax1x.com/2022/07/04/jGNy5Q.png" alt="jGNy5Q.png"></a></p><p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><a href="https://imgtu.com/i/jGNcCj"><img src="https://s1.ax1x.com/2022/07/04/jGNcCj.png" alt="jGNcCj.png"></a></p><p><strong>按下 ESC 按钮回到一般模式</strong></p><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><p>在一般模式中按下 <strong>:wq</strong> 储存后离开 vim！</p><p><a href="https://imgtu.com/i/jGNRvq"><img src="https://s1.ax1x.com/2022/07/04/jGNRvq.png" alt="jGNRvq.png"></a></p><p>OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。</p><h3 id="Vim-按键说明"><a href="#Vim-按键说明" class="headerlink" title="Vim 按键说明"></a>Vim 按键说明</h3><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td style="text-align:left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td style="text-align:left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td style="text-align:left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td style="text-align:left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td style="text-align:left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td style="text-align:left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td style="text-align:left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td style="text-align:left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td style="text-align:left"><strong>n(数字)&lt; space&gt;</strong></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td></tr><tr><td style="text-align:left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td style="text-align:left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td style="text-align:left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td style="text-align:left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td style="text-align:left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td style="text-align:left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td style="text-align:left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td style="text-align:left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td></tr><tr><td style="text-align:left"><strong>n&lt; Enter&gt;</strong></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">搜索替换</th><th></th></tr></thead><tbody><tr><td style="text-align:left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)</td></tr><tr><td style="text-align:left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td style="text-align:left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td style="text-align:left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">删除、复制与粘贴</th><th></th></tr></thead><tbody><tr><td style="text-align:left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td style="text-align:left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td style="text-align:left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td style="text-align:left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td style="text-align:left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td style="text-align:left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td style="text-align:left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td style="text-align:left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td style="text-align:left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td style="text-align:left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td style="text-align:left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td style="text-align:left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td style="text-align:left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td style="text-align:left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td style="text-align:left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td></tr><tr><td style="text-align:left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td style="text-align:left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td style="text-align:left"><strong>u</strong></td><td>复原前一个动作。(常用)</td></tr><tr><td style="text-align:left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr></tbody></table></div><p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td style="text-align:left"><strong>i, I</strong></td><td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td></tr><tr><td style="text-align:left">a, A</td><td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td style="text-align:left">o, O</td><td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td style="text-align:left">r, R</td><td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td style="text-align:left"><strong>[Esc]</strong></td><td>退出编辑模式，回到一般模式中(常用)</td></tr><tr><td style="text-align:left">Insert</td><td>切换光标的状态</td></tr></tbody></table></div><p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td style="text-align:left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td style="text-align:left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td style="text-align:left">:q</td><td>离开 vi (常用)</td></tr><tr><td style="text-align:left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td style="text-align:left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td style="text-align:left"><strong>:wq</strong></td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td style="text-align:left">ZZ</td><td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td style="text-align:left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td style="text-align:left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td style="text-align:left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td style="text-align:left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td style="text-align:left"><strong>:set nu</strong>     设置行号，代码中经常会使用</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td style="text-align:left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table></div><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p>因为你一般在公司，用的都不是root账号</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul><h3 id="用户账号的管理"><a href="#用户账号的管理" class="headerlink" title="用户账号的管理"></a>用户账号的管理</h3><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p><p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p><p>要明白一个属主和属组的区别</p><h4 id="添加账号-useradd"><a href="#添加账号-useradd" class="headerlink" title="添加账号 useradd"></a>添加账号 useradd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>选项 :</p></li><li><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li><strong>-m　使用者目录如不存在则自动建立。</strong>（常用）</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul></li><li><p>用户名 :</p><ul><li>指定新账号的登录名。</li></ul></li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此命令创建了一个用户gods，其中-m选项用来为登录名gods产生一个主目录 /home/gods</span></span><br><span class="line">[root@apathy home]<span class="comment"># useradd -m gods</span></span><br></pre></td></tr></table></figure><p>理解一下本质:Linux中一切皆文件，这里的添加用户说白了就是往某一个文件中写入用户的信息了!/etc/passwd</p><p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p><h4 id="删除帐号-userdel"><a href="#删除帐号-userdel" class="headerlink" title="删除帐号  userdel"></a>删除帐号  userdel</h4><p>如果一个用户的账号不再使用，可以从系统中删除。</p><p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p><p>删除一个已有的用户账号使用userdel命令，其格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure><p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@apathy home]<span class="comment"># userdel -r gods</span></span><br></pre></td></tr></table></figure><p>此命令删除用户gods在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p><h4 id="修改帐号-usermod"><a href="#修改帐号-usermod" class="headerlink" title="修改帐号  usermod"></a>修改帐号  usermod</h4><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><p>修改已有用户的信息使用usermod命令，其格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure><p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -s /bin/ksh -d /home/z –g developer gods</span></span><br></pre></td></tr></table></figure><p>此命令将用户apathy的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p><h4 id="Linux下如何切换用户"><a href="#Linux下如何切换用户" class="headerlink" title="Linux下如何切换用户"></a>Linux下如何切换用户</h4><p><a href="https://imgtu.com/i/jGNfK0"><img src="https://s1.ax1x.com/2022/07/04/jGNfK0.png" alt="jGNfK0.png"></a></p><p>1.切换用户的命令为：su username 【username是你的用户名哦】</p><p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p><p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p><p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p><p>$表示普通用户</p><p>#表示超级用户，也就是root用户</p><p><a href="https://imgtu.com/i/jGNhrV"><img src="https://s1.ax1x.com/2022/07/04/jGNhrV.png" alt="jGNhrV.png"></a></p><p>如何修改主机名？</p><p><a href="https://imgtu.com/i/jGN4bT"><img src="https://s1.ax1x.com/2022/07/04/jGN4bT.png" alt="jGN4bT.png"></a></p><h4 id="用户密码的管理"><a href="#用户密码的管理" class="headerlink" title="用户密码的管理"></a>用户密码的管理</h4><ul><li>我们一般通过root创建用户的时候!要配置密码!</li><li>Linux上输入密码是不会显示的，你正常输入就可以了，并不是系统的问题!</li><li>在公司中，你们一般拿不到公司服务器的root权限，都是一些分配的账号!</li></ul><p>用户管理的一项重要内容是用户密码的管理。用户账号刚创建时没有密码，但是被系统锁定，无法使用，必须为其指定密码后才可以使用，即使是指定空密码。</p><p>指定和修改用户密码的Shell命令是passwd。超级用户可以为自己和其他用户指定密码，普通用户只能用它修改自己的密码。</p><p>命令的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure><p>可使用的选项：</p><ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁。</li><li>-d 使账号无口令。</li><li>-f 强迫用户下次登录时修改口令。</li></ul><p>如果默认用户名，则修改当前用户的口令。</p><p>例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">Old password:******</span><br><span class="line">New password:*******   <span class="comment">#密码不能过于简单</span></span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd kuangshen</span></span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure><p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p><p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p><p>为用户指定空口令时，执行下列形式的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -d kuangshen   </span></span><br></pre></td></tr></table></figure><p>此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。</p><p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -l kuangshen   锁定之后用户就不能登录了</span></span><br></pre></td></tr></table></figure><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><h3 id="用户组账号管理"><a href="#用户组账号管理" class="headerlink" title="用户组账号管理"></a>用户组账号管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（开发，测试，运维，root）。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。<strong>组的增加、删除和修改实际上就是对/etc/group文件的更新</strong>。</p><h4 id="增加一个新的用户组使用groupadd命令"><a href="#增加一个新的用户组使用groupadd命令" class="headerlink" title="增加一个新的用户组使用groupadd命令"></a>增加一个新的用户组使用groupadd命令</h4><p>创建完用户组后可以得到一个组的id，这个id是可以指定的!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure><p>可以使用的选项有：</p><ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><p>实例1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># groupadd group1</span></span><br></pre></td></tr></table></figure><p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p><p>实例2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># groupadd -g 101 group2</span></span><br></pre></td></tr></table></figure><p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p><h4 id="如果要删除一个已有的用户组，使用groupdel命令"><a href="#如果要删除一个已有的用户组，使用groupdel命令" class="headerlink" title="如果要删除一个已有的用户组，使用groupdel命令"></a>如果要删除一个已有的用户组，使用groupdel命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># groupdel group1</span></span><br></pre></td></tr></table></figure><p>此命令从系统中删除组group1。</p><h4 id="修改用户组的属性使用groupmod命令"><a href="#修改用户组的属性使用groupmod命令" class="headerlink" title="修改用户组的属性使用groupmod命令"></a>修改用户组的属性使用groupmod命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure><p>常用的选项有：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此命令将组group2的组标识号修改为102。</span></span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将组group2的标识号改为10000，组名修改为group3。</span></span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/jGNIVU"><img src="https://s1.ax1x.com/2022/07/04/jGNIVU.png" alt="jGNIVU.png"></a></p><h4 id="切换组"><a href="#切换组" class="headerlink" title="切换组"></a>切换组</h4><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure><p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p><h2 id="扩展：文件的查看"><a href="#扩展：文件的查看" class="headerlink" title="扩展：文件的查看"></a>扩展：文件的查看</h2><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p><p>下面分别介绍这些文件的内容。</p><p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p><p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">＃ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:/:</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br></pre></td></tr></table></figure><p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:口令(登录密码，我们不可见):用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><p>1）”用户名”是代表用户账号的字符串。</p><p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p><p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p><p>2）“口令”一些系统中，存放着加密后的用户口令字。</p><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><p>4）“组标识号”字段记录的是用户所属的用户组。</p><p>它对应着/etc/group文件中的一条记录。</p><p>5)“注释性描述”字段记录着用户的一些个人情况。</p><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p><p>6)“主目录”，也就是用户的起始工作目录。</p><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p><p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><p>8)系统中有一类用户称为伪用户（pseudo users）。</p><p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p><p>常见的伪用户如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">伪 用 户 含 义</span><br><span class="line">bin 拥有可执行的用户命令文件</span><br><span class="line">sys 拥有系统文件</span><br><span class="line">adm 拥有帐户文件</span><br><span class="line">uucp UUCP使用</span><br><span class="line">lp lp或lpd子系统使用</span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p><p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p><p><strong>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</strong></p><p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure><ol><li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li><li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li><li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li><li>“最大时间间隔”指的是口令保持有效的最大天数。</li><li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ol><h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><p>用户组的所有信息都存放在/etc/group文件中。</p><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p><p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p><p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure><ol><li><p>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</p></li><li><p>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</p></li><li><p>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</p></li><li><p>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p></li></ol><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p><p>Linux磁盘管理常用命令为 df、du。</p><ul><li>df ：列出文件系统的整体磁盘使用量</li><li>du：检查磁盘空间使用量</li></ul><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p><a href="https://imgtu.com/i/jGNT54"><img src="https://s1.ax1x.com/2022/07/04/jGNT54.png" alt="jGNT54.png"></a></p><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li><li>-k ：以 KBytes 的容量显示各文件系统；</li><li>-m ：以 MBytes 的容量显示各文件系统；</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将系统内所有的文件系统列出来！</span></span><br><span class="line"><span class="comment"># 在 Linux 底下如果 df 没有加任何选项</span></span><br><span class="line"><span class="comment"># 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks   Used Available Use% Mounted on</span><br><span class="line">devtmpfs          889100       0    889100   0% /dev</span><br><span class="line">tmpfs             899460     704    898756   1% /dev/shm</span><br><span class="line">tmpfs             899460     496    898964   1% /run</span><br><span class="line">tmpfs             899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       41152812 6586736  32662368  17% /</span><br><span class="line">tmpfs             179896       0    179896   0% /run/user/0</span><br><span class="line"><span class="comment"># 将容量结果以易读的容量格式显示出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">devtmpfs       869M     0 869M   0% /dev</span><br><span class="line">tmpfs           879M 708K 878M   1% /dev/shm</span><br><span class="line">tmpfs           879M 496K 878M   1% /run</span><br><span class="line">tmpfs           879M     0 879M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br><span class="line">tmpfs           176M     0 176M   0% /run/user/0</span><br><span class="line"><span class="comment"># 将系统内的所有特殊文件格式及名称都列出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -aT</span></span><br><span class="line">Filesystem     Type       1K-blocks   Used Available Use% Mounted on</span><br><span class="line">sysfs         sysfs               0       0         0    - /sys</span><br><span class="line">proc           proc                0       0         0    - /proc</span><br><span class="line">devtmpfs       devtmpfs       889100       0    889100   0% /dev</span><br><span class="line">securityfs     securityfs          0       0         0    - /sys/kernel/security</span><br><span class="line">tmpfs         tmpfs          899460     708    898752   1% /dev/shm</span><br><span class="line">devpts         devpts              0       0         0    - /dev/pts</span><br><span class="line">tmpfs         tmpfs          899460     496    898964   1% /run</span><br><span class="line">tmpfs         tmpfs          899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/systemd</span><br><span class="line">pstore         pstore              0       0         0    - /sys/fs/pstore</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/freezer</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpuset</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/hugetlb</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/blkio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/net_cls,net_prio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/memory</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/pids</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/devices</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/perf_event</span><br><span class="line">configfs       configfs            0       0         0    - /sys/kernel/config</span><br><span class="line">/dev/vda1     ext4         41152812 6586748  32662356  17% /</span><br><span class="line">systemd-1      -                   -       -         -    - /proc/sys/fs/binfmt_misc</span><br><span class="line">mqueue         mqueue              0       0         0    - /dev/mqueue</span><br><span class="line">debugfs       debugfs             0       0         0    - /sys/kernel/debug</span><br><span class="line">hugetlbfs     hugetlbfs           0       0         0    - /dev/hugepages</span><br><span class="line">tmpfs         tmpfs          179896       0    179896   0% /run/user/0</span><br><span class="line">binfmt_misc   binfmt_misc         0       0         0    - /proc/sys/fs/binfmt_misc</span><br><span class="line"><span class="comment"># 将 /etc 底下的可用的磁盘容量以易读的容量格式显示</span></span><br><span class="line"></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h /etc</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br></pre></td></tr></table></figure><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p><a href="https://imgtu.com/i/jGNoaF"><img src="https://s1.ax1x.com/2022/07/04/jGNoaF.png" alt="jGNoaF.png"></a></p><p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G/M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:</span></span><br><span class="line"><span class="comment"># 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du</span></span><br><span class="line">16./redis</span><br><span class="line">8./www/.oracle_jre_usage  <span class="comment"># 包括隐藏文件的目录</span></span><br><span class="line">24./www</span><br><span class="line">48.                        <span class="comment"># 这个目录(.)所占用的总量</span></span><br><span class="line"><span class="comment"># 将文件的容量也列出来</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -a</span></span><br><span class="line">4./redis/.bash_profile</span><br><span class="line">4./redis/.bash_logout    </span><br><span class="line">....中间省略....</span><br><span class="line">4./kuangstudy.txt <span class="comment"># 有文件的列表了</span></span><br><span class="line">48.</span><br><span class="line"><span class="comment"># 检查根目录底下每个目录所占用的容量</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -sm /*</span></span><br><span class="line">0/bin</span><br><span class="line">146/boot</span><br><span class="line">.....中间省略....</span><br><span class="line">0/proc</span><br><span class="line">.....中间省略....</span><br><span class="line">1/tmp</span><br><span class="line">3026/usr  <span class="comment"># 系统初期最大就是他了啦！</span></span><br><span class="line">513/var</span><br><span class="line">2666/www</span><br></pre></td></tr></table></figure><p>通配符 * 来代表每个目录。</p><p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p><h3 id="磁盘挂载与卸除"><a href="#磁盘挂载与卸除" class="headerlink" title="磁盘挂载与卸除"></a>磁盘挂载与卸除</h3><p><a href="https://imgtu.com/i/jGNHPJ"><img src="https://s1.ax1x.com/2022/07/04/jGNHPJ.png" alt="jGNHPJ.png"></a></p><p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”</p><p>Linux 的磁盘挂载使用mount命令，卸载使用umount命令。</p><p>磁盘挂载语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！</span></span><br><span class="line">[root@www ~]<span class="comment"># mkdir /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># mount /dev/hdc6 /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># df</span></span><br><span class="line">Filesystem           1K-blocks     Used Available Use% Mounted on</span><br><span class="line">/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6</span><br></pre></td></tr></table></figure><p>磁盘卸载命令 umount 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li><li>-n ：不升级 /etc/mtab 情况下卸除。</li></ul><p>卸载/dev/hdc6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># umount /dev/hdc6</span></span><br></pre></td></tr></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>对于我们开发人员来说，其实Linux更多偏向于使用即可</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、在Linux中，每一个程序都是有自己的一个进程，每一个进程都有一个id号</p><p>2、每一个进程呢，都会有一个父进程</p><p>3、进程可以有两种存在方式:前台!后台运行</p><p>4、一般的话服务都是后台运行的，基本的程序都是前台运行的</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><strong>ps（常用）</strong> 查看当前系统中正在执行的各种进程的信息</p><p>ps-xx:</p><ul><li>-a 显示当前终端运行的所有的进程信息（单独使用时是查看当前的进程）</li><li>-u 以用户的信息显示进程</li><li>-x 显示后台运行进程的参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -aux 查看所有的进程</span></span><br><span class="line">ps -aux | grep mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># |  在Linux中这个(|)叫做管道符     A|B：将A命令的一个结果作为输出去操作B命令</span></span><br><span class="line"><span class="comment"># grep 查找文件中符合条件的字符串</span></span><br></pre></td></tr></table></figure><p>对于我们来说，这里目前只需要记住一个命令即可：ps -xx|grep 进程名字  过滤进程信息</p><p><strong>ps -ef：可以查看到父进程的信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep mysql <span class="comment">#查看父进程我们一般可以通过目录树结构来查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程树</span></span><br><span class="line">pstree -pu</span><br><span class="line">-p  显示父<span class="built_in">id</span></span><br><span class="line">-u  显示用户组</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/jGNq2R"><img src="https://s1.ax1x.com/2022/07/04/jGNq2R.png" alt="jGNq2R.png"></a></p><p>结束进程:杀掉进程，等价于window结束任务</p><p>kill -9进程的id</p><p>我们平时写的一个Java代码死循环了，可以选择结束进程，杀进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 进程的<span class="built_in">id</span></span><br><span class="line"><span class="comment"># 表示强制结束该进程</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>Linux中一切皆文件：<strong>(文件∶读写执行(查看，创建，删除，移动，复制，编辑），权限（用户、用户组)。系统︰（磁盘，进程）)</strong></p><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>安装软件一般有三种方式:</p><ul><li>rpm ( Jdk:在线发布一个SringBoot项目)</li><li>解压缩( tomcat，启动并通过外网访问，发布网站)</li><li>yum在线安装(docker:直接安装运行跑起来docker就可以) </li></ul><h2 id="jdk安装（rpm安装）"><a href="#jdk安装（rpm安装）" class="headerlink" title="jdk安装（rpm安装）"></a>jdk安装（rpm安装）</h2><p>1、rpm下载地址<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>2、如果有安装openjdk 则卸载</p><p><a href="https://imgtu.com/i/jGNbG9"><img src="https://s1.ax1x.com/2022/07/04/jGNbG9.png" alt="jGNbG9.png"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen ~]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_121&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># rpm -qa|grep jdk</span></span><br><span class="line">jdk1.8.0_121-1.8.0_121-fcs.x86_64</span><br><span class="line"><span class="comment"># 卸载 -e --nodeps 强制删除</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># java -version</span></span><br><span class="line">-bash: /usr/bin/java: No such file or directory  <span class="comment"># OK</span></span><br></pre></td></tr></table></figure><p>3、安装JDK并配置环境变量</p><p><a href="https://imgtu.com/i/jGNLx1"><img src="https://s1.ax1x.com/2022/07/04/jGNLx1.png" alt="jGNLx1.png"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装java rpm</span></span><br><span class="line">[root@apathy apathy]<span class="comment"># rpm -ivh jdk-8u221-linux-x64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完成后配置环境变量 文件：/etc/profile</span></span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_333-amd64</span><br><span class="line">CLASSPATH=$JAVA_HOME$/lib:$JAVA_HOME$/jre/lib</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH CLASSPATH JAVA_HOME</span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让新增的环境变量生效！</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 java -version</span></span><br><span class="line">[root@apathy java]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_221&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_221-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>注意：在Linux中配置环境变量不应该使用%，应该用$,分隔符也不是分号;,而是英文的冒号:</strong></p><p><strong>配置环境变量前先看下有没有环境变量，因为阿里云使用rpm安装jdk可能会自动帮你配好</strong></p><h2 id="Tomcat安装（解压缩安装）"><a href="#Tomcat安装（解压缩安装）" class="headerlink" title="Tomcat安装（解压缩安装）"></a>Tomcat安装（解压缩安装）</h2><p>1、安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！</p><p>2、将文件移动到/usr/tomcat/下，并解压！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen kuangshen]<span class="comment"># mv apache-tomcat-9.0.22.tar.gz /usr</span></span><br><span class="line">[root@kuangshen kuangshen]<span class="comment"># cd /usr</span></span><br><span class="line">[root@kuangshen usr]<span class="comment"># ls</span></span><br><span class="line">apache-tomcat-9.0.22.tar.gz</span><br><span class="line">[root@kuangshen usr]<span class="comment"># tar -zxvf apache-tomcat-9.0.22.tar.gz   # 解压</span></span><br></pre></td></tr></table></figure><p>3、运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行：startup.sh --&gt;启动tomcat</span></span><br><span class="line"><span class="comment"># 执行：shutdown.sh --&gt;关闭tomcat</span></span><br><span class="line">./startup.sh</span><br><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure><p>4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看firewall服务状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启、重启、关闭、firewalld.service服务</span></span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all    <span class="comment"># 查看全部信息</span></span><br><span class="line">firewall-cmd --list-ports  <span class="comment"># 只看端口信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启端口</span></span><br><span class="line">开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone <span class="comment">#作用域</span></span><br><span class="line">--add-port=80/tcp  <span class="comment">#添加端口，格式为：端口/通讯协议</span></span><br><span class="line">--permanent   <span class="comment">#永久生效，没有此参数重启后失效</span></span><br></pre></td></tr></table></figure><h2 id="安装Docker（yum安装）"><a href="#安装Docker（yum安装）" class="headerlink" title="安装Docker（yum安装）"></a>安装Docker（yum安装）</h2><blockquote><p>基于 CentOS 7 安装</p></blockquote><ol><li><p>官网安装参考手册：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p></li><li><p>确定你是CentOS7及以上版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@192 Desktop]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.2.1511 (Core)</span><br></pre></td></tr></table></figure></li><li><p>yum安装gcc相关（需要确保 虚拟机可以上外网 ）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure></li><li><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br><span class="line"><span class="comment"># 官网版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">          docker-client \</span><br><span class="line">          docker-client-latest \</span><br><span class="line">          docker-common \</span><br><span class="line">          docker-latest \</span><br><span class="line">          docker-latest-logrotate \</span><br><span class="line">          docker-logrotate \</span><br><span class="line">          docker-engine</span><br></pre></td></tr></table></figure></li><li><p>安装需要的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>设置stable镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">## 报错</span></span><br><span class="line">[Errno 14] curl<span class="comment">#35 - TCP connection reset by peer</span></span><br><span class="line">[Errno 12] curl<span class="comment">#35 - Timeout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确推荐使用国内的</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>更新yum软件包索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ol><h2 id="宝塔面板安装"><a href="#宝塔面板安装" class="headerlink" title="宝塔面板安装"></a>宝塔面板安装</h2><p><a href="https://www.bilibili.com/video/av91821322">https://www.bilibili.com/video/av91821322</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>先来了解下北秋趴</title>
      <link href="/post/c8f15973.html"/>
      <url>/post/c8f15973.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍:"></a>1.自我介绍:</h1><p>大家好我是北秋，一名深耕互联网项目多年的00后博主<br><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
